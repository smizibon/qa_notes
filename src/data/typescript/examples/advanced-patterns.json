{
  "id": "examples-advanced-patterns",
  "title": "Advanced Patterns - Practical Examples",
  "description": "Real-world examples of advanced TypeScript patterns: mapped types, conditional types, template literals, and more",
  "examples": [
    {
      "title": "Type-Safe Event Emitter",
      "code": "// Define events with their payload types\ninterface Events {\n  userLoggedIn: { userId: string; timestamp: Date };\n  userLoggedOut: { userId: string };\n  itemAddedToCart: { productId: string; quantity: number };\n  orderPlaced: { orderId: string; total: number };\n}\n\n// Generate handler type names\ntype EventHandler<K extends keyof Events> = `on${Capitalize<string & K>}`;\n\nclass EventEmitter {\n  private handlers: {\n    [K in keyof Events]?: Array<(payload: Events[K]) => void>;\n  } = {};\n\n  on<K extends keyof Events>(\n    event: K,\n    handler: (payload: Events[K]) => void\n  ): void {\n    if (!this.handlers[event]) {\n      this.handlers[event] = [];\n    }\n    this.handlers[event]!.push(handler);\n  }\n\n  emit<K extends keyof Events>(event: K, payload: Events[K]): void {\n    const eventHandlers = this.handlers[event];\n    if (eventHandlers) {\n      eventHandlers.forEach(handler => handler(payload));\n    }\n  }\n\n  off<K extends keyof Events>(\n    event: K,\n    handler: (payload: Events[K]) => void\n  ): void {\n    const eventHandlers = this.handlers[event];\n    if (eventHandlers) {\n      const index = eventHandlers.indexOf(handler);\n      if (index > -1) {\n        eventHandlers.splice(index, 1);\n      }\n    }\n  }\n}\n\n// Usage - fully type-safe!\nconst emitter = new EventEmitter();\n\nemitter.on('userLoggedIn', ({ userId, timestamp }) => {\n  console.log(`User ${userId} logged in at ${timestamp}`);\n});\n\nemitter.on('itemAddedToCart', ({ productId, quantity }) => {\n  console.log(`Added ${quantity} of ${productId} to cart`);\n});\n\n// Type-safe emit\nemitter.emit('userLoggedIn', { userId: '123', timestamp: new Date() });\nemitter.emit('itemAddedToCart', { productId: 'ABC', quantity: 2 });\n\n// Type errors:\n// emitter.emit('userLoggedIn', { userId: 123 });  // wrong type\n// emitter.emit('unknownEvent', {});  // unknown event",
      "explanation": "Mapped types with template literals create type-safe event systems where payloads are validated at compile time."
    },
    {
      "title": "Builder Pattern with Conditional Types",
      "code": "// Required fields tracker\ntype RequiredFields = 'name' | 'email' | 'age';\n\ninterface UserData {\n  name: string;\n  email: string;\n  age: number;\n  phone?: string;\n  address?: string;\n}\n\n// Builder state tracks which required fields are set\ntype BuilderState = {\n  [K in RequiredFields]?: true;\n};\n\n// Check if all required fields are set\ntype IsComplete<S extends BuilderState> = \n  S extends Record<RequiredFields, true> ? true : false;\n\nclass UserBuilder<S extends BuilderState = {}> {\n  private data: Partial<UserData> = {};\n\n  setName(name: string): UserBuilder<S & { name: true }> {\n    this.data.name = name;\n    return this as unknown as UserBuilder<S & { name: true }>;\n  }\n\n  setEmail(email: string): UserBuilder<S & { email: true }> {\n    this.data.email = email;\n    return this as unknown as UserBuilder<S & { email: true }>;\n  }\n\n  setAge(age: number): UserBuilder<S & { age: true }> {\n    this.data.age = age;\n    return this as unknown as UserBuilder<S & { age: true }>;\n  }\n\n  setPhone(phone: string): UserBuilder<S> {\n    this.data.phone = phone;\n    return this;\n  }\n\n  setAddress(address: string): UserBuilder<S> {\n    this.data.address = address;\n    return this;\n  }\n\n  // Only available when all required fields are set\n  build(this: UserBuilder<Record<RequiredFields, true>>): UserData {\n    return this.data as UserData;\n  }\n}\n\n// Usage\nconst user = new UserBuilder()\n  .setName('Alice')\n  .setEmail('alice@example.com')\n  .setAge(30)\n  .setPhone('555-1234')  // Optional\n  .build();  // ✓ OK - all required fields set\n\n// This would be a type error:\n// new UserBuilder()\n//   .setName('Bob')\n//   .setEmail('bob@example.com')\n//   .build();  // ✗ Error - missing age",
      "explanation": "Conditional types track builder state, preventing build() until all required fields are set."
    },
    {
      "title": "Deep Object Utilities",
      "code": "// Deep Partial - all nested properties optional\ntype DeepPartial<T> = T extends object\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : T;\n\n// Deep Readonly - all nested properties readonly\ntype DeepReadonly<T> = T extends object\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : T;\n\n// Deep Required - all nested properties required\ntype DeepRequired<T> = T extends object\n  ? { [K in keyof T]-?: DeepRequired<T[K]> }\n  : T;\n\n// Get all paths in an object as dot-notation strings\ntype Paths<T, Prefix extends string = ''> = T extends object\n  ? {\n      [K in keyof T]: K extends string\n        ? Prefix extends ''\n          ? Paths<T[K], K> | K\n          : Paths<T[K], `${Prefix}.${K}`> | `${Prefix}.${K}`\n        : never;\n    }[keyof T]\n  : never;\n\ninterface User {\n  name: string;\n  profile: {\n    age: number;\n    address: {\n      street: string;\n      city: string;\n      country: string;\n    };\n  };\n  settings: {\n    theme: 'light' | 'dark';\n    notifications: boolean;\n  };\n}\n\n// Usage\ntype UserPaths = Paths<User>;\n// = 'name' | 'profile' | 'profile.age' | 'profile.address' | \n//   'profile.address.street' | 'profile.address.city' | \n//   'profile.address.country' | 'settings' | 'settings.theme' | \n//   'settings.notifications'\n\ntype PartialUser = DeepPartial<User>;\ntype ReadonlyUser = DeepReadonly<User>;\ntype RequiredUser = DeepRequired<User>;\n\n// Example: partial updates at any nesting level\nfunction updateUser(id: string, updates: DeepPartial<User>): void {\n  console.log(`Updating user ${id}:`, updates);\n}\n\nupdateUser('123', {\n  profile: {\n    address: {\n      city: 'New York'  // Only updating city\n    }\n  }\n});",
      "explanation": "Recursive mapped types create deep utilities that work at any nesting level."
    },
    {
      "title": "Type-Safe API Route Definitions",
      "code": "// Define route config\ninterface RouteConfig {\n  params?: Record<string, string>;\n  query?: Record<string, string | number | boolean>;\n  body?: Record<string, unknown>;\n  response: unknown;\n}\n\n// Route definitions\ninterface API {\n  'GET /users': {\n    query: { page?: number; limit?: number };\n    response: { users: User[]; total: number };\n  };\n  'GET /users/:id': {\n    params: { id: string };\n    response: User;\n  };\n  'POST /users': {\n    body: { name: string; email: string };\n    response: User;\n  };\n  'PUT /users/:id': {\n    params: { id: string };\n    body: Partial<User>;\n    response: User;\n  };\n  'DELETE /users/:id': {\n    params: { id: string };\n    response: { success: boolean };\n  };\n}\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// Extract method from route\ntype ExtractMethod<R extends string> = R extends `${infer M} ${string}` ? M : never;\n\n// Extract path from route\ntype ExtractPath<R extends string> = R extends `${string} ${infer P}` ? P : never;\n\n// Build request options type\ntype RequestOptions<R extends keyof API> = \n  (API[R] extends { params: infer P } ? { params: P } : {}) &\n  (API[R] extends { query: infer Q } ? { query?: Q } : {}) &\n  (API[R] extends { body: infer B } ? { body: B } : {});\n\n// Type-safe API client\nasync function apiRequest<R extends keyof API>(\n  route: R,\n  options: RequestOptions<R>\n): Promise<API[R]['response']> {\n  const [method, path] = (route as string).split(' ');\n  \n  // Replace path params\n  let url = path;\n  if ('params' in options && options.params) {\n    Object.entries(options.params).forEach(([key, value]) => {\n      url = url.replace(`:${key}`, String(value));\n    });\n  }\n  \n  // Add query params\n  if ('query' in options && options.query) {\n    const params = new URLSearchParams();\n    Object.entries(options.query).forEach(([key, value]) => {\n      if (value !== undefined) params.append(key, String(value));\n    });\n    url += `?${params.toString()}`;\n  }\n  \n  const response = await fetch(url, {\n    method,\n    headers: { 'Content-Type': 'application/json' },\n    body: 'body' in options ? JSON.stringify(options.body) : undefined,\n  });\n  \n  return response.json();\n}\n\n// Usage - fully type-safe!\nasync function example() {\n  // GET with query params\n  const list = await apiRequest('GET /users', {\n    query: { page: 1, limit: 10 }\n  });\n  console.log(list.users, list.total);\n\n  // GET with path params\n  const user = await apiRequest('GET /users/:id', {\n    params: { id: '123' }\n  });\n  console.log(user.name);\n\n  // POST with body\n  const created = await apiRequest('POST /users', {\n    body: { name: 'Alice', email: 'alice@example.com' }\n  });\n  console.log(created.id);\n}",
      "explanation": "Template literals and conditional types create a type-safe API client with validated params, query, body, and response types."
    },
    {
      "title": "State Machine with Discriminated Unions",
      "code": "// Define all possible states\ntype LoadingState<T> =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error };\n\n// Valid state transitions\ntype Transitions<T> = {\n  idle: { load: LoadingState<T> & { status: 'loading' } };\n  loading: {\n    success: LoadingState<T> & { status: 'success' };\n    error: LoadingState<T> & { status: 'error' };\n  };\n  success: { reload: LoadingState<T> & { status: 'loading' } };\n  error: { retry: LoadingState<T> & { status: 'loading' } };\n};\n\n// Extract valid actions for a state\ntype ValidActions<S extends LoadingState<any>['status']> = keyof Transitions<any>[S];\n\nclass StateMachine<T> {\n  constructor(private state: LoadingState<T> = { status: 'idle' }) {}\n\n  getState(): LoadingState<T> {\n    return this.state;\n  }\n\n  load(this: StateMachine<T> & { getState(): { status: 'idle' } }): void;\n  load(this: StateMachine<T>): void {\n    if (this.state.status === 'idle') {\n      this.state = { status: 'loading' };\n    }\n  }\n\n  success(data: T): void {\n    if (this.state.status === 'loading') {\n      this.state = { status: 'success', data };\n    }\n  }\n\n  error(error: Error): void {\n    if (this.state.status === 'loading') {\n      this.state = { status: 'error', error };\n    }\n  }\n\n  retry(): void {\n    if (this.state.status === 'error') {\n      this.state = { status: 'loading' };\n    }\n  }\n\n  reload(): void {\n    if (this.state.status === 'success') {\n      this.state = { status: 'loading' };\n    }\n  }\n}\n\n// React-style hook example\nfunction useAsyncData<T>(fetcher: () => Promise<T>) {\n  const machine = new StateMachine<T>();\n\n  async function fetch() {\n    machine.load();\n    try {\n      const data = await fetcher();\n      machine.success(data);\n    } catch (e) {\n      machine.error(e instanceof Error ? e : new Error(String(e)));\n    }\n  }\n\n  return {\n    state: machine.getState(),\n    fetch,\n    retry: () => {\n      machine.retry();\n      fetch();\n    },\n    reload: () => {\n      machine.reload();\n      fetch();\n    }\n  };\n}\n\n// Usage\nconst { state, fetch, retry } = useAsyncData(async () => {\n  const res = await globalThis.fetch('/api/users');\n  return res.json();\n});\n\nif (state.status === 'success') {\n  console.log(state.data); // Type is inferred!\n} else if (state.status === 'error') {\n  console.error(state.error.message);\n}",
      "explanation": "Discriminated unions with mapped types model state machines with valid transitions."
    },
    {
      "title": "String Parsing with Template Literals",
      "code": "// Parse route parameters from path\ntype ExtractParams<Path extends string> =\n  Path extends `${string}:${infer Param}/${infer Rest}`\n    ? Param | ExtractParams<`/${Rest}`>\n    : Path extends `${string}:${infer Param}`\n    ? Param\n    : never;\n\ntype UserRouteParams = ExtractParams<'/users/:userId/posts/:postId'>;\n// = 'userId' | 'postId'\n\n// Build params object type\ntype RouteParams<Path extends string> = {\n  [K in ExtractParams<Path>]: string;\n};\n\ntype UserPostParams = RouteParams<'/users/:userId/posts/:postId'>;\n// = { userId: string; postId: string }\n\n// Type-safe route matching\nfunction createRoute<P extends string>(\n  pattern: P,\n  handler: (params: RouteParams<P>) => void\n): void {\n  // Implementation would parse URL and extract params\n  console.log('Registered route:', pattern);\n}\n\n// Usage\ncreateRoute('/users/:userId', (params) => {\n  console.log(params.userId); // ✓ Type-safe\n});\n\ncreateRoute('/users/:userId/posts/:postId', (params) => {\n  console.log(params.userId, params.postId); // ✓ Both params typed\n});\n\n// Parse query string types\ntype ParseQueryString<S extends string> =\n  S extends `${infer Key}=${infer Value}&${infer Rest}`\n    ? { [K in Key]: Value } & ParseQueryString<Rest>\n    : S extends `${infer Key}=${infer Value}`\n    ? { [K in Key]: Value }\n    : {};\n\ntype Query = ParseQueryString<'page=1&limit=10&sort=name'>;\n// = { page: '1' } & { limit: '10' } & { sort: 'name' }",
      "explanation": "Template literal types with infer can parse string patterns at compile time."
    },
    {
      "title": "Tuple Manipulation",
      "code": "// First element of tuple\ntype First<T extends unknown[]> = T extends [infer F, ...unknown[]] ? F : never;\n\n// Last element of tuple\ntype Last<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;\n\n// All but first element\ntype Tail<T extends unknown[]> = T extends [unknown, ...infer Rest] ? Rest : never;\n\n// All but last element\ntype Init<T extends unknown[]> = T extends [...infer Rest, unknown] ? Rest : never;\n\n// Prepend element to tuple\ntype Prepend<T extends unknown[], E> = [E, ...T];\n\n// Append element to tuple\ntype Append<T extends unknown[], E> = [...T, E];\n\n// Reverse tuple\ntype Reverse<T extends unknown[]> = T extends [infer F, ...infer Rest]\n  ? [...Reverse<Rest>, F]\n  : [];\n\n// Flatten nested tuples\ntype Flatten<T extends unknown[]> = T extends [infer F, ...infer Rest]\n  ? F extends unknown[]\n    ? [...Flatten<F>, ...Flatten<Rest>]\n    : [F, ...Flatten<Rest>]\n  : [];\n\n// Examples\ntype TestTuple = [string, number, boolean, Date];\n\ntype FirstEl = First<TestTuple>;   // string\ntype LastEl = Last<TestTuple>;     // Date\ntype TailEls = Tail<TestTuple>;    // [number, boolean, Date]\ntype InitEls = Init<TestTuple>;    // [string, number, boolean]\n\ntype WithPrefix = Prepend<TestTuple, null>; // [null, string, number, boolean, Date]\ntype WithSuffix = Append<TestTuple, undefined>; // [string, number, boolean, Date, undefined]\n\ntype Reversed = Reverse<TestTuple>; // [Date, boolean, number, string]\n\ntype Nested = [[1, 2], [3, [4, 5]], 6];\ntype Flat = Flatten<Nested>; // [1, 2, 3, 4, 5, 6]\n\n// Practical use: function composition\ntype ComposeResult<Fns extends Array<(arg: any) => any>> =\n  Fns extends [infer First, ...infer Rest]\n    ? First extends (arg: any) => infer R\n      ? Rest extends Array<(arg: any) => any>\n        ? (arg: Parameters<First extends (...args: any) => any ? First : never>[0]) => \n            ReturnType<Last<Rest> extends (...args: any) => any ? Last<Rest> : never>\n        : R\n      : never\n    : never;",
      "explanation": "Advanced tuple manipulation enables type-safe operations on fixed-length arrays."
    },
    {
      "title": "Function Overloads from Union",
      "code": "// Create overloaded function type from union of signatures\ntype Overload<T> = T extends unknown\n  ? (x: T) => void\n  : never;\n\n// UnionToIntersection utility\ntype UnionToIntersection<U> = \n  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) \n    ? I \n    : never;\n\n// Create overloaded function\ntype CreateOverloadedFn<T extends Record<string, unknown>> = UnionToIntersection<\n  { [K in keyof T]: (type: K, payload: T[K]) => void }[keyof T]\n>;\n\n// Event definitions\ninterface EventPayloads {\n  click: { x: number; y: number };\n  keypress: { key: string; code: number };\n  submit: { formData: FormData };\n}\n\ntype EventDispatcher = CreateOverloadedFn<EventPayloads>;\n// Equivalent to:\n// {\n//   (type: 'click', payload: { x: number; y: number }): void;\n//   (type: 'keypress', payload: { key: string; code: number }): void;\n//   (type: 'submit', payload: { formData: FormData }): void;\n// }\n\n// Implementation\nconst dispatch: EventDispatcher = (type, payload) => {\n  console.log(`Dispatching ${type}:`, payload);\n};\n\n// Usage - each call is type-checked against correct payload\ndispatch('click', { x: 100, y: 200 });       // ✓\ndispatch('keypress', { key: 'Enter', code: 13 }); // ✓\ndispatch('submit', { formData: new FormData() });  // ✓\n\n// Type errors:\n// dispatch('click', { key: 'a' });  // ✗ Wrong payload\n// dispatch('unknown', {});          // ✗ Unknown event",
      "explanation": "UnionToIntersection creates overloaded function types from union definitions."
    }
  ]
}
