{
  "id": "examples-type-aliases",
  "title": "Type Aliases Examples",
  "description": "Practical examples demonstrating TypeScript type aliases for reusable types",
  "examples": [
    {
      "title": "Status and State Types",
      "description": "Using type aliases for application state management",
      "code": "// Define status types\ntype LoadingState = 'idle' | 'loading' | 'success' | 'error';\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\ntype Theme = 'light' | 'dark' | 'system';\n\n// Application state\ntype AppState = {\n  user: User | null;\n  theme: Theme;\n  loading: LoadingState;\n  notifications: Notification[];\n};\n\n// Usage\nlet currentState: LoadingState = 'idle';\ncurrentState = 'loading'; // ✓ OK\n// currentState = 'pending'; // ✗ Error: not in union\n\nfunction setTheme(theme: Theme): void {\n  console.log(`Theme set to: ${theme}`);\n  document.body.className = `theme-${theme}`;\n}\n\nsetTheme('dark');  // ✓ OK\n// setTheme('blue'); // ✗ Error: not in union\n\n// Type-safe status transitions\nfunction updateLoadingState(current: LoadingState, next: LoadingState): void {\n  console.log(`State: ${current} → ${next}`);\n}",
      "explanation": "Literal union types create type-safe status values that prevent invalid states."
    },
    {
      "title": "Union Types for API Responses",
      "description": "Discriminated unions for handling success and error states",
      "code": "// Success response type\ntype SuccessResponse<T> = {\n  success: true;\n  data: T;\n  timestamp: string;\n};\n\n// Error response type\ntype ErrorResponse = {\n  success: false;\n  error: {\n    code: string;\n    message: string;\n    details?: string;\n  };\n  timestamp: string;\n};\n\n// Combined API response\ntype ApiResponse<T> = SuccessResponse<T> | ErrorResponse;\n\n// User type\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n};\n\n// Type-safe response handling\nfunction handleUserResponse(response: ApiResponse<User>): void {\n  if (response.success) {\n    // TypeScript knows response is SuccessResponse<User>\n    console.log(`Welcome, ${response.data.name}!`);\n    console.log(`Email: ${response.data.email}`);\n  } else {\n    // TypeScript knows response is ErrorResponse\n    console.error(`Error ${response.error.code}: ${response.error.message}`);\n  }\n}\n\n// Usage\nconst successResponse: ApiResponse<User> = {\n  success: true,\n  data: { id: 1, name: 'Alice', email: 'alice@example.com' },\n  timestamp: new Date().toISOString()\n};\n\nconst errorResponse: ApiResponse<User> = {\n  success: false,\n  error: { code: 'USER_NOT_FOUND', message: 'User does not exist' },\n  timestamp: new Date().toISOString()\n};\n\nhandleUserResponse(successResponse);\nhandleUserResponse(errorResponse);",
      "explanation": "Discriminated unions use a common property ('success') to distinguish between types."
    },
    {
      "title": "Intersection Types for Composition",
      "description": "Combining types to build complex structures",
      "code": "// Base types\ntype Identifiable = {\n  id: number;\n};\n\ntype Timestamped = {\n  createdAt: Date;\n  updatedAt: Date;\n};\n\ntype Auditable = {\n  createdBy: string;\n  updatedBy: string;\n};\n\ntype SoftDeletable = {\n  deletedAt?: Date;\n  isDeleted: boolean;\n};\n\n// Combine types with intersection\ntype BaseEntity = Identifiable & Timestamped;\ntype AuditableEntity = BaseEntity & Auditable;\ntype FullEntity = AuditableEntity & SoftDeletable;\n\n// Use with specific types\ntype User = BaseEntity & {\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n};\n\ntype Post = FullEntity & {\n  title: string;\n  content: string;\n  published: boolean;\n};\n\n// Usage\nconst user: User = {\n  id: 1,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  name: 'Alice',\n  email: 'alice@example.com',\n  role: 'admin'\n};\n\nconst post: Post = {\n  id: 101,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  createdBy: 'alice',\n  updatedBy: 'alice',\n  deletedAt: undefined,\n  isDeleted: false,\n  title: 'TypeScript Guide',\n  content: 'Learning TypeScript...',\n  published: true\n};",
      "explanation": "Intersection types combine multiple types into one, inheriting all properties."
    },
    {
      "title": "Function Type Aliases",
      "description": "Defining reusable function signatures",
      "code": "// Basic function types\ntype Predicate<T> = (item: T) => boolean;\ntype Transformer<T, U> = (input: T) => U;\ntype Comparator<T> = (a: T, b: T) => number;\ntype EventHandler<T> = (event: T) => void;\n\n// Async function types\ntype AsyncFetcher<T> = (url: string) => Promise<T>;\ntype AsyncValidator<T> = (data: T) => Promise<boolean>;\n\n// Usage with Predicate\nconst isEven: Predicate<number> = (n) => n % 2 === 0;\nconst isAdult: Predicate<{ age: number }> = (person) => person.age >= 18;\n\nconst numbers = [1, 2, 3, 4, 5];\nconsole.log(numbers.filter(isEven)); // [2, 4]\n\n// Usage with Transformer\nconst toUpperCase: Transformer<string, string> = (s) => s.toUpperCase();\nconst toNumber: Transformer<string, number> = (s) => parseInt(s, 10);\nconst toJson: Transformer<object, string> = (obj) => JSON.stringify(obj);\n\nconsole.log(toUpperCase('hello')); // 'HELLO'\nconsole.log(toNumber('42'));        // 42\n\n// Higher-order function using type aliases\nfunction map<T, U>(arr: T[], transform: Transformer<T, U>): U[] {\n  return arr.map(transform);\n}\n\nconst doubled = map([1, 2, 3], n => n * 2); // [2, 4, 6]\nconst names = map(['alice', 'bob'], toUpperCase); // ['ALICE', 'BOB']",
      "explanation": "Function type aliases make callback signatures clear and reusable."
    },
    {
      "title": "Tuple Types",
      "description": "Fixed-length arrays with specific types",
      "code": "// Coordinate types\ntype Point2D = [number, number];\ntype Point3D = [number, number, number];\ntype Size = [width: number, height: number]; // Named tuple elements\n\n// RGB and RGBA colors\ntype RGB = [red: number, green: number, blue: number];\ntype RGBA = [red: number, green: number, blue: number, alpha: number];\n\n// Result tuple (Go/Rust style error handling)\ntype Result<T, E = Error> = [T, null] | [null, E];\n\n// Usage\nconst origin: Point2D = [0, 0];\nconst point: Point3D = [10, 20, 30];\nconst screenSize: Size = [1920, 1080];\nconst red: RGB = [255, 0, 0];\nconst transparentBlue: RGBA = [0, 0, 255, 0.5];\n\n// Destructuring tuples\nconst [x, y] = origin;\nconst [width, height] = screenSize;\nconst [r, g, b, a] = transparentBlue;\n\n// Result type usage\nfunction divide(a: number, b: number): Result<number> {\n  if (b === 0) {\n    return [null, new Error('Division by zero')];\n  }\n  return [a / b, null];\n}\n\nconst [result, error] = divide(10, 2);\nif (error) {\n  console.error(error.message);\n} else {\n  console.log('Result:', result); // 5\n}",
      "explanation": "Tuples provide fixed-length, typed arrays perfect for coordinates, colors, and multi-return values."
    },
    {
      "title": "Recursive Types",
      "description": "Self-referencing types for nested structures",
      "code": "// JSON value type (recursive)\ntype JSONValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n// Tree node type\ntype TreeNode<T> = {\n  value: T;\n  children: TreeNode<T>[];\n};\n\n// File system structure\ntype FileSystemItem = {\n  name: string;\n} & (\n  | { type: 'file'; size: number; extension: string }\n  | { type: 'folder'; children: FileSystemItem[] }\n);\n\n// Usage - JSON\nconst config: JSONValue = {\n  name: 'my-app',\n  version: '1.0.0',\n  settings: {\n    debug: true,\n    ports: [3000, 3001],\n    database: {\n      host: 'localhost',\n      port: 5432\n    }\n  }\n};\n\n// Usage - Tree\nconst orgChart: TreeNode<string> = {\n  value: 'CEO',\n  children: [\n    {\n      value: 'CTO',\n      children: [\n        { value: 'Dev Lead', children: [] },\n        { value: 'QA Lead', children: [] }\n      ]\n    },\n    {\n      value: 'CFO',\n      children: [{ value: 'Accountant', children: [] }]\n    }\n  ]\n};\n\n// Usage - File System\nconst projectFolder: FileSystemItem = {\n  name: 'project',\n  type: 'folder',\n  children: [\n    { name: 'src', type: 'folder', children: [\n      { name: 'index.ts', type: 'file', size: 1024, extension: '.ts' }\n    ]},\n    { name: 'README.md', type: 'file', size: 2048, extension: '.md' }\n  ]\n};",
      "explanation": "Recursive types reference themselves to model deeply nested structures like trees and file systems."
    },
    {
      "title": "Conditional Type Aliases",
      "description": "Types that change based on conditions",
      "code": "// Basic conditional type\ntype IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>;  // true\ntype B = IsString<number>;  // false\ntype C = IsString<'hello'>; // true\n\n// Extract array element type\ntype ElementType<T> = T extends (infer E)[] ? E : T;\n\ntype D = ElementType<string[]>;  // string\ntype E = ElementType<number[]>;  // number\ntype F = ElementType<string>;    // string (not an array)\n\n// Unwrap Promise type\ntype Awaited<T> = T extends Promise<infer R> ? Awaited<R> : T;\n\ntype G = Awaited<Promise<string>>;           // string\ntype H = Awaited<Promise<Promise<number>>>;  // number\ntype I = Awaited<string>;                    // string\n\n// Conditional property types\ntype MessageOf<T> = T extends { message: unknown } ? T['message'] : never;\n\ninterface Email { message: string; subject: string; }\ninterface User { name: string; age: number; }\n\ntype J = MessageOf<Email>;  // string\ntype K = MessageOf<User>;   // never\n\n// Practical example: API response wrapper\ntype ApiResult<T> = T extends void\n  ? { success: true }\n  : { success: true; data: T };\n\ntype DeleteResult = ApiResult<void>;  // { success: true }\ntype GetUserResult = ApiResult<User>; // { success: true; data: User }",
      "explanation": "Conditional types use 'extends' to create types that vary based on input types."
    },
    {
      "title": "Template Literal Types",
      "description": "String types with interpolation",
      "code": "// Event name patterns\ntype EventName = `on${Capitalize<string>}`;\ntype ClickEvent = 'onClick';\ntype HoverEvent = 'onHover';\n\n// CSS property types\ntype CSSUnit = 'px' | 'em' | 'rem' | '%' | 'vh' | 'vw';\ntype CSSValue = `${number}${CSSUnit}`;\n\nconst width: CSSValue = '100px';   // ✓ OK\nconst height: CSSValue = '50vh';   // ✓ OK\n// const invalid: CSSValue = '100';  // ✗ Error: needs unit\n\n// HTTP endpoints\ntype Version = 'v1' | 'v2';\ntype Resource = 'users' | 'posts' | 'comments';\ntype ApiEndpoint = `/api/${Version}/${Resource}`;\n\nconst usersEndpoint: ApiEndpoint = '/api/v1/users';     // ✓ OK\nconst postsEndpoint: ApiEndpoint = '/api/v2/posts';     // ✓ OK\n// const invalid: ApiEndpoint = '/api/v3/users';        // ✗ Error: v3 not allowed\n\n// Object property event handlers\ntype ObjectEventName<T extends string> = `on${Capitalize<T>}Change`;\n\ntype UserEvents = ObjectEventName<'name' | 'email' | 'age'>;\n// 'onNameChange' | 'onEmailChange' | 'onAgeChange'\n\n// Getter/Setter patterns\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype Person = { name: string; age: number };\ntype PersonGetters = Getters<Person>;\n// { getName: () => string; getAge: () => number }",
      "explanation": "Template literal types create string patterns with type-safe interpolation."
    }
  ]
}
