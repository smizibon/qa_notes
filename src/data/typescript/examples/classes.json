{
  "id": "examples-classes",
  "title": "Classes Examples",
  "description": "Practical examples demonstrating TypeScript classes and object-oriented programming",
  "examples": [
    {
      "title": "Basic Class with Methods",
      "description": "Simple class demonstrating properties, constructor, and methods",
      "code": "class User {\n  name: string;\n  email: string;\n  private password: string;\n  readonly createdAt: Date;\n\n  constructor(name: string, email: string, password: string) {\n    this.name = name;\n    this.email = email;\n    this.password = password;\n    this.createdAt = new Date();\n  }\n\n  greet(): string {\n    return `Hello, I'm ${this.name}!`;\n  }\n\n  updateEmail(newEmail: string): void {\n    this.email = newEmail;\n    console.log(`Email updated to: ${this.email}`);\n  }\n\n  validatePassword(input: string): boolean {\n    return this.password === input; // Private field accessed internally\n  }\n}\n\nconst user = new User('Alice', 'alice@example.com', 'secret123');\nconsole.log(user.greet());                    // \"Hello, I'm Alice!\"\nconsole.log(user.name);                       // \"Alice\"\nconsole.log(user.validatePassword('secret123')); // true\n// console.log(user.password);                // Error: private property",
      "explanation": "Demonstrates public, private, and readonly properties with typed methods."
    },
    {
      "title": "Parameter Properties Shorthand",
      "description": "Using constructor parameter properties for cleaner code",
      "code": "// Long form\nclass ProductLong {\n  id: number;\n  name: string;\n  price: number;\n  private cost: number;\n\n  constructor(id: number, name: string, price: number, cost: number) {\n    this.id = id;\n    this.name = name;\n    this.price = price;\n    this.cost = cost;\n  }\n}\n\n// Shorthand with parameter properties\nclass Product {\n  constructor(\n    public readonly id: number,\n    public name: string,\n    public price: number,\n    private cost: number\n  ) {}\n\n  getProfit(): number {\n    return this.price - this.cost;\n  }\n\n  getMargin(): string {\n    const margin = ((this.price - this.cost) / this.price) * 100;\n    return `${margin.toFixed(2)}%`;\n  }\n}\n\nconst laptop = new Product(1, 'MacBook Pro', 1999, 1200);\nconsole.log(laptop.name);           // \"MacBook Pro\"\nconsole.log(laptop.getProfit());    // 799\nconsole.log(laptop.getMargin());    // \"39.97%\"\n// laptop.id = 2;                   // Error: readonly\n// console.log(laptop.cost);        // Error: private",
      "explanation": "Parameter properties automatically create and initialize class properties from constructor parameters."
    },
    {
      "title": "Inheritance and Method Overriding",
      "description": "Extending classes and customizing behavior",
      "code": "class Employee {\n  constructor(\n    public name: string,\n    public email: string,\n    protected baseSalary: number\n  ) {}\n\n  work(): void {\n    console.log(`${this.name} is working...`);\n  }\n\n  getAnnualSalary(): number {\n    return this.baseSalary * 12;\n  }\n\n  getInfo(): string {\n    return `${this.name} (${this.email})`;\n  }\n}\n\nclass Developer extends Employee {\n  constructor(\n    name: string,\n    email: string,\n    baseSalary: number,\n    public languages: string[]\n  ) {\n    super(name, email, baseSalary); // Call parent constructor\n  }\n\n  // Override parent method\n  work(): void {\n    console.log(`${this.name} is coding in ${this.languages.join(', ')}...`);\n  }\n\n  code(language: string): void {\n    console.log(`${this.name} is writing ${language} code.`);\n  }\n}\n\nclass Manager extends Employee {\n  private team: Employee[] = [];\n\n  constructor(name: string, email: string, baseSalary: number) {\n    super(name, email, baseSalary);\n  }\n\n  // Override with bonus\n  getAnnualSalary(): number {\n    const base = super.getAnnualSalary(); // Call parent method\n    const bonus = base * 0.2; // 20% bonus\n    return base + bonus;\n  }\n\n  addToTeam(employee: Employee): void {\n    this.team.push(employee);\n  }\n\n  getTeamSize(): number {\n    return this.team.length;\n  }\n}\n\nconst dev = new Developer('Alice', 'alice@company.com', 8000, ['TypeScript', 'Python']);\nconst manager = new Manager('Bob', 'bob@company.com', 10000);\n\ndev.work();      // \"Alice is coding in TypeScript, Python...\"\ndev.code('TypeScript');\n\nmanager.addToTeam(dev);\nconsole.log(manager.getAnnualSalary()); // 144000 (with 20% bonus)\nconsole.log(manager.getTeamSize());     // 1",
      "explanation": "Shows inheritance, super calls, method overriding, and class-specific features."
    },
    {
      "title": "Abstract Classes",
      "description": "Using abstract classes as blueprints for related classes",
      "code": "abstract class PaymentProcessor {\n  constructor(\n    protected merchantId: string,\n    protected apiKey: string\n  ) {}\n\n  // Abstract methods - must be implemented\n  abstract processPayment(amount: number): Promise<boolean>;\n  abstract refund(transactionId: string): Promise<boolean>;\n\n  // Concrete methods - shared implementation\n  protected log(message: string): void {\n    console.log(`[${this.merchantId}] ${message}`);\n  }\n\n  validateAmount(amount: number): boolean {\n    return amount > 0 && amount < 1000000;\n  }\n}\n\nclass StripeProcessor extends PaymentProcessor {\n  async processPayment(amount: number): Promise<boolean> {\n    if (!this.validateAmount(amount)) {\n      this.log('Invalid amount');\n      return false;\n    }\n    this.log(`Processing $${amount} via Stripe...`);\n    // Simulate API call\n    return true;\n  }\n\n  async refund(transactionId: string): Promise<boolean> {\n    this.log(`Refunding transaction ${transactionId} via Stripe...`);\n    return true;\n  }\n}\n\nclass PayPalProcessor extends PaymentProcessor {\n  async processPayment(amount: number): Promise<boolean> {\n    this.log(`Processing $${amount} via PayPal...`);\n    return true;\n  }\n\n  async refund(transactionId: string): Promise<boolean> {\n    this.log(`Refunding transaction ${transactionId} via PayPal...`);\n    return true;\n  }\n}\n\n// const processor = new PaymentProcessor(...); // Error: cannot instantiate abstract class\n\nconst stripe = new StripeProcessor('merchant123', 'sk_test_xxx');\nconst paypal = new PayPalProcessor('merchant123', 'client_id_xxx');\n\nawait stripe.processPayment(99.99);\nawait paypal.processPayment(49.99);",
      "explanation": "Abstract classes define contracts that concrete classes must fulfill while sharing common functionality."
    },
    {
      "title": "Implementing Interfaces",
      "description": "Classes implementing multiple interfaces",
      "code": "interface Serializable {\n  toJSON(): string;\n  fromJSON(json: string): void;\n}\n\ninterface Printable {\n  print(): void;\n}\n\ninterface Identifiable {\n  readonly id: string;\n}\n\nclass Document implements Serializable, Printable, Identifiable {\n  readonly id: string;\n\n  constructor(\n    public title: string,\n    public content: string,\n    public author: string\n  ) {\n    this.id = `doc_${Date.now()}`;\n  }\n\n  // Implement Serializable\n  toJSON(): string {\n    return JSON.stringify({\n      id: this.id,\n      title: this.title,\n      content: this.content,\n      author: this.author\n    });\n  }\n\n  fromJSON(json: string): void {\n    const data = JSON.parse(json);\n    this.title = data.title;\n    this.content = data.content;\n    this.author = data.author;\n  }\n\n  // Implement Printable\n  print(): void {\n    console.log(`\\n--- ${this.title} ---`);\n    console.log(`By: ${this.author}`);\n    console.log(`\\n${this.content}`);\n    console.log(`\\nDocument ID: ${this.id}`);\n  }\n}\n\nconst doc = new Document(\n  'TypeScript Guide',\n  'TypeScript is a typed superset of JavaScript...',\n  'Alice'\n);\n\ndoc.print();\nconst json = doc.toJSON();\nconsole.log('Serialized:', json);",
      "explanation": "A class can implement multiple interfaces, ensuring it provides all required methods."
    },
    {
      "title": "Static Members and Factory Pattern",
      "description": "Using static properties and methods for shared behavior",
      "code": "class Logger {\n  private static instance: Logger | null = null;\n  private static logLevel: 'debug' | 'info' | 'warn' | 'error' = 'info';\n  private logs: string[] = [];\n\n  // Private constructor for singleton\n  private constructor() {}\n\n  // Static factory method\n  static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  static setLogLevel(level: 'debug' | 'info' | 'warn' | 'error'): void {\n    Logger.logLevel = level;\n  }\n\n  private shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n    const levels = ['debug', 'info', 'warn', 'error'];\n    return levels.indexOf(level) >= levels.indexOf(Logger.logLevel);\n  }\n\n  private log(level: string, message: string): void {\n    const timestamp = new Date().toISOString();\n    const entry = `[${timestamp}] [${level.toUpperCase()}] ${message}`;\n    this.logs.push(entry);\n    console.log(entry);\n  }\n\n  debug(message: string): void {\n    if (this.shouldLog('debug')) this.log('debug', message);\n  }\n\n  info(message: string): void {\n    if (this.shouldLog('info')) this.log('info', message);\n  }\n\n  warn(message: string): void {\n    if (this.shouldLog('warn')) this.log('warn', message);\n  }\n\n  error(message: string): void {\n    if (this.shouldLog('error')) this.log('error', message);\n  }\n\n  getLogs(): string[] {\n    return [...this.logs];\n  }\n}\n\n// Usage - Singleton pattern\nLogger.setLogLevel('debug');\n\nconst logger1 = Logger.getInstance();\nconst logger2 = Logger.getInstance();\n\nconsole.log(logger1 === logger2); // true - same instance\n\nlogger1.info('Application started');\nlogger1.debug('Loading configuration...');\nlogger1.warn('Config file not found, using defaults');\nlogger1.error('Failed to connect to database');",
      "explanation": "Demonstrates static methods, singleton pattern, and factory methods for controlled instantiation."
    },
    {
      "title": "Getters and Setters",
      "description": "Using accessor properties for computed values and validation",
      "code": "class Temperature {\n  private _celsius: number;\n\n  constructor(celsius: number) {\n    this._celsius = celsius;\n  }\n\n  // Getter for celsius\n  get celsius(): number {\n    return this._celsius;\n  }\n\n  // Setter with validation\n  set celsius(value: number) {\n    if (value < -273.15) {\n      throw new Error('Temperature cannot be below absolute zero');\n    }\n    this._celsius = value;\n  }\n\n  // Computed property - fahrenheit\n  get fahrenheit(): number {\n    return (this._celsius * 9/5) + 32;\n  }\n\n  set fahrenheit(value: number) {\n    this._celsius = (value - 32) * 5/9;\n  }\n\n  // Computed property - kelvin\n  get kelvin(): number {\n    return this._celsius + 273.15;\n  }\n\n  set kelvin(value: number) {\n    if (value < 0) {\n      throw new Error('Kelvin cannot be negative');\n    }\n    this._celsius = value - 273.15;\n  }\n}\n\nconst temp = new Temperature(25);\n\nconsole.log(`${temp.celsius}°C`);    // 25°C\nconsole.log(`${temp.fahrenheit}°F`); // 77°F\nconsole.log(`${temp.kelvin}K`);      // 298.15K\n\n// Set using different units\ntemp.fahrenheit = 100;\nconsole.log(`${temp.celsius}°C`);    // 37.78°C\n\ntemp.kelvin = 300;\nconsole.log(`${temp.celsius}°C`);    // 26.85°C\n\n// Validation kicks in\n// temp.celsius = -300; // Error: Temperature cannot be below absolute zero",
      "explanation": "Getters and setters provide computed properties and validation while maintaining a clean interface."
    },
    {
      "title": "Generic Classes",
      "description": "Creating reusable classes with type parameters",
      "code": "class Queue<T> {\n  private items: T[] = [];\n\n  enqueue(item: T): void {\n    this.items.push(item);\n  }\n\n  dequeue(): T | undefined {\n    return this.items.shift();\n  }\n\n  peek(): T | undefined {\n    return this.items[0];\n  }\n\n  isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n\n  size(): number {\n    return this.items.length;\n  }\n}\n\nclass Stack<T> {\n  private items: T[] = [];\n\n  push(item: T): void {\n    this.items.push(item);\n  }\n\n  pop(): T | undefined {\n    return this.items.pop();\n  }\n\n  peek(): T | undefined {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n}\n\n// Type-safe queue of numbers\nconst numberQueue = new Queue<number>();\nnumberQueue.enqueue(1);\nnumberQueue.enqueue(2);\nnumberQueue.enqueue(3);\nconsole.log(numberQueue.dequeue()); // 1 (FIFO)\nconsole.log(numberQueue.dequeue()); // 2\n\n// Type-safe stack of strings\nconst stringStack = new Stack<string>();\nstringStack.push('first');\nstringStack.push('second');\nstringStack.push('third');\nconsole.log(stringStack.pop()); // 'third' (LIFO)\nconsole.log(stringStack.pop()); // 'second'\n\n// Queue of custom objects\ninterface Task {\n  id: number;\n  name: string;\n  priority: 'low' | 'high';\n}\n\nconst taskQueue = new Queue<Task>();\ntaskQueue.enqueue({ id: 1, name: 'Build feature', priority: 'high' });\ntaskQueue.enqueue({ id: 2, name: 'Fix bug', priority: 'low' });\n\nconst nextTask = taskQueue.peek();\nconsole.log(nextTask?.name); // 'Build feature'",
      "explanation": "Generic classes work with any type while maintaining type safety throughout their operations."
    }
  ]
}
