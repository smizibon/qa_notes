{
  "id": "examples-type-guards",
  "title": "Type Guards - Practical Examples",
  "description": "Real-world examples of TypeScript type guards for runtime type checking and type narrowing",
  "examples": [
    {
      "title": "API Response Type Guards",
      "code": "interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface ApiError {\n  code: number;\n  message: string;\n  details?: string;\n}\n\nfunction isUser(data: unknown): data is User {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'id' in data &&\n    'name' in data &&\n    'email' in data &&\n    typeof (data as User).id === 'number' &&\n    typeof (data as User).name === 'string' &&\n    typeof (data as User).email === 'string'\n  );\n}\n\nfunction isApiError(data: unknown): data is ApiError {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'code' in data &&\n    'message' in data &&\n    typeof (data as ApiError).code === 'number' &&\n    typeof (data as ApiError).message === 'string'\n  );\n}\n\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  const data: unknown = await response.json();\n  \n  if (isApiError(data)) {\n    throw new Error(`API Error ${data.code}: ${data.message}`);\n  }\n  \n  if (isUser(data)) {\n    return data;\n  }\n  \n  throw new Error('Invalid API response format');\n}\n\n// Usage\nfetchUser(123)\n  .then(user => console.log(`Hello, ${user.name}!`))\n  .catch(err => console.error(err.message));",
      "explanation": "Custom type guards validate API responses safely. Always treat external data as 'unknown' and validate before use."
    },
    {
      "title": "Discriminated Union for State Management",
      "code": "type AsyncState<T> =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error };\n\nfunction renderState<T>(state: AsyncState<T>): string {\n  switch (state.status) {\n    case 'idle':\n      return 'Click to load...';\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return `Data: ${JSON.stringify(state.data)}`;\n    case 'error':\n      return `Error: ${state.error.message}`;\n    default:\n      // Exhaustiveness check\n      const _never: never = state;\n      throw new Error(`Unhandled state: ${_never}`);\n  }\n}\n\n// React-style example\ninterface User { name: string; }\n\nfunction UserComponent({ state }: { state: AsyncState<User> }) {\n  if (state.status === 'loading') {\n    return '‚è≥ Loading user...';\n  }\n  \n  if (state.status === 'error') {\n    return `‚ùå ${state.error.message}`;\n  }\n  \n  if (state.status === 'success') {\n    return `‚úÖ Hello, ${state.data.name}!`;\n  }\n  \n  return 'üîµ Click to load';\n}\n\n// Usage\nconst successState: AsyncState<User> = {\n  status: 'success',\n  data: { name: 'Alice' }\n};\n\nconsole.log(renderState(successState)); // 'Data: {\"name\":\"Alice\"}'",
      "explanation": "Discriminated unions with a 'status' field are perfect for representing async operation states."
    },
    {
      "title": "Form Validation with Type Guards",
      "code": "interface ValidForm {\n  valid: true;\n  data: {\n    email: string;\n    password: string;\n    age: number;\n  };\n}\n\ninterface InvalidForm {\n  valid: false;\n  errors: {\n    field: string;\n    message: string;\n  }[];\n}\n\ntype FormResult = ValidForm | InvalidForm;\n\nfunction validateForm(formData: Record<string, unknown>): FormResult {\n  const errors: { field: string; message: string }[] = [];\n  \n  // Validate email\n  if (typeof formData.email !== 'string') {\n    errors.push({ field: 'email', message: 'Email is required' });\n  } else if (!formData.email.includes('@')) {\n    errors.push({ field: 'email', message: 'Invalid email format' });\n  }\n  \n  // Validate password\n  if (typeof formData.password !== 'string') {\n    errors.push({ field: 'password', message: 'Password is required' });\n  } else if (formData.password.length < 8) {\n    errors.push({ field: 'password', message: 'Password must be at least 8 characters' });\n  }\n  \n  // Validate age\n  if (typeof formData.age !== 'number') {\n    errors.push({ field: 'age', message: 'Age must be a number' });\n  } else if (formData.age < 18) {\n    errors.push({ field: 'age', message: 'Must be 18 or older' });\n  }\n  \n  if (errors.length > 0) {\n    return { valid: false, errors };\n  }\n  \n  return {\n    valid: true,\n    data: {\n      email: formData.email as string,\n      password: formData.password as string,\n      age: formData.age as number\n    }\n  };\n}\n\nfunction handleSubmit(formData: Record<string, unknown>): void {\n  const result = validateForm(formData);\n  \n  if (result.valid) {\n    // TypeScript knows result is ValidForm\n    console.log('Submitting:', result.data.email);\n  } else {\n    // TypeScript knows result is InvalidForm\n    result.errors.forEach(e => {\n      console.error(`${e.field}: ${e.message}`);\n    });\n  }\n}\n\n// Usage\nhandleSubmit({ email: 'test@example.com', password: 'secure123', age: 25 });",
      "explanation": "Using discriminated unions to return either valid data or validation errors, with full type safety."
    },
    {
      "title": "Event Handler Type Guards",
      "code": "type ClickEvent = {\n  type: 'click';\n  x: number;\n  y: number;\n  target: string;\n};\n\ntype KeyEvent = {\n  type: 'keydown' | 'keyup';\n  key: string;\n  ctrlKey: boolean;\n  shiftKey: boolean;\n};\n\ntype ScrollEvent = {\n  type: 'scroll';\n  scrollTop: number;\n  scrollLeft: number;\n};\n\ntype DOMEvent = ClickEvent | KeyEvent | ScrollEvent;\n\nfunction isClickEvent(event: DOMEvent): event is ClickEvent {\n  return event.type === 'click';\n}\n\nfunction isKeyEvent(event: DOMEvent): event is KeyEvent {\n  return event.type === 'keydown' || event.type === 'keyup';\n}\n\nfunction handleEvent(event: DOMEvent): void {\n  if (isClickEvent(event)) {\n    console.log(`Clicked at (${event.x}, ${event.y}) on ${event.target}`);\n    return;\n  }\n  \n  if (isKeyEvent(event)) {\n    const modifiers = [\n      event.ctrlKey && 'Ctrl',\n      event.shiftKey && 'Shift',\n      event.key\n    ].filter(Boolean).join('+');\n    \n    console.log(`Key ${event.type}: ${modifiers}`);\n    return;\n  }\n  \n  // Must be ScrollEvent\n  console.log(`Scrolled to (${event.scrollLeft}, ${event.scrollTop})`);\n}\n\n// Usage\nhandleEvent({ type: 'click', x: 100, y: 200, target: 'button' });\nhandleEvent({ type: 'keydown', key: 'S', ctrlKey: true, shiftKey: false });\nhandleEvent({ type: 'scroll', scrollTop: 500, scrollLeft: 0 });",
      "explanation": "Custom type guard functions make event handling code cleaner and more readable."
    },
    {
      "title": "Array Filtering with Type Predicates",
      "code": "// Filter out null/undefined\nfunction isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\n// Filter to specific type\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !Number.isNaN(value);\n}\n\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction isNonEmptyString(value: unknown): value is string {\n  return typeof value === 'string' && value.trim().length > 0;\n}\n\n// Generic array type guard\nfunction isArrayOf<T>(\n  value: unknown,\n  guard: (item: unknown) => item is T\n): value is T[] {\n  return Array.isArray(value) && value.every(guard);\n}\n\n// Usage examples\nconst mixed: (string | number | null | undefined)[] = [\n  'hello', null, 42, undefined, 'world', 0, ''\n];\n\nconst defined = mixed.filter(isDefined);\n// Type: (string | number)[]\nconsole.log(defined); // ['hello', 42, 'world', 0, '']\n\nconst strings = mixed.filter(isString);\n// Type: string[]\nconsole.log(strings); // ['hello', 'world', '']\n\nconst nonEmptyStrings = mixed.filter(isNonEmptyString);\n// Type: string[]\nconsole.log(nonEmptyStrings); // ['hello', 'world']\n\nconst numbers = mixed.filter(isNumber);\n// Type: number[]\nconsole.log(numbers); // [42, 0]\n\n// Check external data\nconst externalData: unknown = [1, 2, 3, 4, 5];\nif (isArrayOf(externalData, isNumber)) {\n  // externalData is number[]\n  const sum = externalData.reduce((a, b) => a + b, 0);\n  console.log('Sum:', sum); // 15\n}",
      "explanation": "Type predicates in filter callbacks properly narrow array types. Essential for processing external data."
    },
    {
      "title": "Assertion Functions for Validation",
      "code": "// Basic assertion\nfunction assert(condition: boolean, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message ?? 'Assertion failed');\n  }\n}\n\n// Type assertion\nfunction assertIsString(value: unknown): asserts value is string {\n  if (typeof value !== 'string') {\n    throw new TypeError(`Expected string, got ${typeof value}`);\n  }\n}\n\nfunction assertIsDefined<T>(\n  value: T | null | undefined,\n  name?: string\n): asserts value is T {\n  if (value === null || value === undefined) {\n    throw new Error(`${name ?? 'Value'} must be defined`);\n  }\n}\n\n// Complex object assertion\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n  retries: number;\n}\n\nfunction assertIsConfig(value: unknown): asserts value is Config {\n  assert(typeof value === 'object' && value !== null, 'Config must be an object');\n  assert('apiUrl' in value, 'Config must have apiUrl');\n  assert('timeout' in value, 'Config must have timeout');\n  assert('retries' in value, 'Config must have retries');\n  \n  const obj = value as Record<string, unknown>;\n  assertIsString(obj.apiUrl);\n  assert(typeof obj.timeout === 'number', 'timeout must be a number');\n  assert(typeof obj.retries === 'number', 'retries must be a number');\n}\n\n// Usage\nfunction loadConfig(data: unknown): Config {\n  assertIsConfig(data);\n  // After this line, data is guaranteed to be Config\n  return data;\n}\n\nconst rawConfig: unknown = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3\n};\n\nconst config = loadConfig(rawConfig);\nconsole.log(`API URL: ${config.apiUrl}`);",
      "explanation": "Assertion functions throw if conditions aren't met, and TypeScript narrows types after the assertion succeeds."
    },
    {
      "title": "Error Handling with Type Guards",
      "code": "class NetworkError extends Error {\n  constructor(public statusCode: number, message: string) {\n    super(message);\n    this.name = 'NetworkError';\n  }\n}\n\nclass ValidationError extends Error {\n  constructor(public field: string, message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass AuthenticationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'AuthenticationError';\n  }\n}\n\nfunction isNetworkError(error: unknown): error is NetworkError {\n  return error instanceof NetworkError;\n}\n\nfunction isValidationError(error: unknown): error is ValidationError {\n  return error instanceof ValidationError;\n}\n\nfunction isAuthError(error: unknown): error is AuthenticationError {\n  return error instanceof AuthenticationError;\n}\n\nfunction isError(error: unknown): error is Error {\n  return error instanceof Error;\n}\n\nasync function apiRequest<T>(url: string): Promise<T> {\n  try {\n    const response = await fetch(url);\n    \n    if (response.status === 401) {\n      throw new AuthenticationError('Please log in');\n    }\n    \n    if (!response.ok) {\n      throw new NetworkError(response.status, 'Request failed');\n    }\n    \n    return await response.json();\n  } catch (error) {\n    // Re-throw our custom errors\n    if (isNetworkError(error) || isAuthError(error) || isValidationError(error)) {\n      throw error;\n    }\n    \n    // Wrap unknown errors\n    if (isError(error)) {\n      throw new NetworkError(0, error.message);\n    }\n    \n    throw new NetworkError(0, 'Unknown error occurred');\n  }\n}\n\n// Usage with error handling\nasync function main() {\n  try {\n    const data = await apiRequest<{ name: string }>('/api/user');\n    console.log(`Hello, ${data.name}!`);\n  } catch (error) {\n    if (isAuthError(error)) {\n      console.log('Redirecting to login...');\n    } else if (isNetworkError(error)) {\n      console.error(`Network error (${error.statusCode}): ${error.message}`);\n    } else if (isValidationError(error)) {\n      console.error(`Validation error in ${error.field}: ${error.message}`);\n    } else {\n      console.error('Unexpected error:', error);\n    }\n  }\n}",
      "explanation": "Use instanceof type guards for custom error classes to handle different error types appropriately."
    },
    {
      "title": "typeof Guard for Primitives",
      "code": "type JsonValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JsonValue[]\n  | { [key: string]: JsonValue };\n\nfunction formatJsonValue(value: JsonValue, indent = 0): string {\n  const spaces = '  '.repeat(indent);\n  \n  if (value === null) {\n    return `${spaces}null`;\n  }\n  \n  if (typeof value === 'string') {\n    return `${spaces}\"${value}\"`;\n  }\n  \n  if (typeof value === 'number') {\n    return `${spaces}${value}`;\n  }\n  \n  if (typeof value === 'boolean') {\n    return `${spaces}${value}`;\n  }\n  \n  if (Array.isArray(value)) {\n    if (value.length === 0) return `${spaces}[]`;\n    const items = value.map(item => formatJsonValue(item, indent + 1));\n    return `${spaces}[\\n${items.join(',\\n')}\\n${spaces}]`;\n  }\n  \n  // Must be object\n  const entries = Object.entries(value);\n  if (entries.length === 0) return `${spaces}{}`;\n  \n  const formatted = entries.map(([key, val]) => {\n    const formattedVal = formatJsonValue(val, indent + 1).trim();\n    return `${'  '.repeat(indent + 1)}\"${key}\": ${formattedVal}`;\n  });\n  \n  return `${spaces}{\\n${formatted.join(',\\n')}\\n${spaces}}`;\n}\n\n// Usage\nconst json: JsonValue = {\n  name: 'Alice',\n  age: 30,\n  active: true,\n  scores: [95, 87, 92],\n  metadata: null\n};\n\nconsole.log(formatJsonValue(json));\n// {\n//   \"name\": \"Alice\",\n//   \"age\": 30,\n//   \"active\": true,\n//   \"scores\": [\n//     95,\n//     87,\n//     92\n//   ],\n//   \"metadata\": null\n// }",
      "explanation": "Using typeof guards to recursively process JSON values of different types."
    }
  ]
}
