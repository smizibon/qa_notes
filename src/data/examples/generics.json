{
  "id": "examples-generics",
  "title": "Generics Examples",
  "description": "Practical examples demonstrating TypeScript generics for reusable, type-safe code",
  "examples": [
    {
      "title": "Generic Identity and Wrapper Functions",
      "description": "Basic generic functions that preserve type information",
      "code": "// Identity function - returns exactly what you pass\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nconst num = identity(42);           // number\nconst str = identity('hello');       // string\nconst obj = identity({ x: 1, y: 2 }); // { x: number; y: number }\n\n// Wrapper function - wraps value in an object\nfunction wrap<T>(value: T): { value: T; timestamp: Date } {\n  return {\n    value,\n    timestamp: new Date()\n  };\n}\n\nconst wrappedNumber = wrap(100);        // { value: number; timestamp: Date }\nconst wrappedString = wrap('data');     // { value: string; timestamp: Date }\n\n// Multiple type parameters\nfunction pair<T, U>(first: T, second: U): [T, U] {\n  return [first, second];\n}\n\nconst nameAge = pair('Alice', 30);    // [string, number]\nconst coordLabel = pair([10, 20], 'origin'); // [number[], string]\n\n// Swap function\nfunction swap<T, U>(tuple: [T, U]): [U, T] {\n  return [tuple[1], tuple[0]];\n}\n\nconst swapped = swap(['hello', 42]);  // [number, string]",
      "explanation": "Generic functions preserve the exact types passed in, enabling type-safe transformations."
    },
    {
      "title": "Generic Array Utilities",
      "description": "Reusable array functions that work with any element type",
      "code": "// Get first element\nfunction first<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// Get last element\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\n// Filter with type guard\nfunction filter<T>(arr: T[], predicate: (item: T) => boolean): T[] {\n  return arr.filter(predicate);\n}\n\n// Map to different type\nfunction map<T, U>(arr: T[], transform: (item: T) => U): U[] {\n  return arr.map(transform);\n}\n\n// Find element\nfunction find<T>(arr: T[], predicate: (item: T) => boolean): T | undefined {\n  return arr.find(predicate);\n}\n\n// Usage\nconst numbers = [1, 2, 3, 4, 5];\nconst users = [\n  { id: 1, name: 'Alice', active: true },\n  { id: 2, name: 'Bob', active: false },\n  { id: 3, name: 'Charlie', active: true }\n];\n\nconsole.log(first(numbers));      // 1\nconsole.log(last(users));         // { id: 3, name: 'Charlie', active: true }\n\nconst activeUsers = filter(users, u => u.active);\nconst userNames = map(users, u => u.name);  // string[]\nconst bob = find(users, u => u.name === 'Bob');",
      "explanation": "These generic utilities work with any array type while maintaining element type information."
    },
    {
      "title": "Generic Constraints",
      "description": "Limiting generic types to ensure required properties exist",
      "code": "// Constraint: must have 'length' property\ninterface HasLength {\n  length: number;\n}\n\nfunction logLength<T extends HasLength>(item: T): void {\n  console.log(`Length: ${item.length}`);\n}\n\nlogLength('hello');           // ✓ strings have length\nlogLength([1, 2, 3]);         // ✓ arrays have length\nlogLength({ length: 10 });    // ✓ object with length\n// logLength(42);             // ✗ Error: numbers don't have length\n\n// Constraint: must have 'id' property\nfunction findById<T extends { id: number }>(items: T[], id: number): T | undefined {\n  return items.find(item => item.id === id);\n}\n\nconst products = [\n  { id: 1, name: 'Laptop', price: 999 },\n  { id: 2, name: 'Mouse', price: 29 }\n];\n\nconst laptop = findById(products, 1); // { id: number; name: string; price: number } | undefined\n\n// keyof constraint - key must exist on object\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst person = { name: 'Alice', age: 30, email: 'alice@example.com' };\nconst name = getProperty(person, 'name');   // string\nconst age = getProperty(person, 'age');     // number\n// getProperty(person, 'invalid');          // ✗ Error: 'invalid' not a key",
      "explanation": "Constraints ensure generic types have required properties, making operations safe."
    },
    {
      "title": "Generic Interfaces and Types",
      "description": "Creating reusable type definitions with type parameters",
      "code": "// Generic response wrapper\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n  timestamp: Date;\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface Product {\n  id: number;\n  title: string;\n  price: number;\n}\n\n// Use with different types\nconst userResponse: ApiResponse<User> = {\n  data: { id: 1, name: 'Alice', email: 'alice@example.com' },\n  status: 200,\n  message: 'Success',\n  timestamp: new Date()\n};\n\nconst productsResponse: ApiResponse<Product[]> = {\n  data: [\n    { id: 1, title: 'Laptop', price: 999 },\n    { id: 2, title: 'Mouse', price: 29 }\n  ],\n  status: 200,\n  message: 'Products fetched',\n  timestamp: new Date()\n};\n\n// Generic Result type for error handling\ntype Result<T, E = Error> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\nfunction divide(a: number, b: number): Result<number, string> {\n  if (b === 0) {\n    return { success: false, error: 'Division by zero' };\n  }\n  return { success: true, value: a / b };\n}\n\nconst result = divide(10, 2);\nif (result.success) {\n  console.log(result.value); // 5\n} else {\n  console.error(result.error);\n}",
      "explanation": "Generic interfaces and types create flexible, reusable type definitions."
    },
    {
      "title": "Generic Classes",
      "description": "Creating type-safe data structures with generics",
      "code": "// Generic Stack implementation\nclass Stack<T> {\n  private items: T[] = [];\n\n  push(item: T): void {\n    this.items.push(item);\n  }\n\n  pop(): T | undefined {\n    return this.items.pop();\n  }\n\n  peek(): T | undefined {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n\n  size(): number {\n    return this.items.length;\n  }\n}\n\n// Generic Queue implementation\nclass Queue<T> {\n  private items: T[] = [];\n\n  enqueue(item: T): void {\n    this.items.push(item);\n  }\n\n  dequeue(): T | undefined {\n    return this.items.shift();\n  }\n\n  front(): T | undefined {\n    return this.items[0];\n  }\n\n  isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n}\n\n// Usage\nconst numberStack = new Stack<number>();\nnumberStack.push(1);\nnumberStack.push(2);\nnumberStack.push(3);\nconsole.log(numberStack.pop());  // 3 (LIFO)\n\nconst taskQueue = new Queue<{ id: number; task: string }>();\ntaskQueue.enqueue({ id: 1, task: 'Build feature' });\ntaskQueue.enqueue({ id: 2, task: 'Fix bug' });\nconsole.log(taskQueue.dequeue()); // { id: 1, task: 'Build feature' } (FIFO)",
      "explanation": "Generic classes create reusable data structures that work with any element type."
    },
    {
      "title": "Generic Factory Pattern",
      "description": "Creating instances with proper typing",
      "code": "// Generic factory function\nfunction createInstance<T>(ctor: new () => T): T {\n  return new ctor();\n}\n\nclass Dog {\n  bark(): void {\n    console.log('Woof!');\n  }\n}\n\nclass Cat {\n  meow(): void {\n    console.log('Meow!');\n  }\n}\n\nconst dog = createInstance(Dog); // Dog\ndog.bark();\n\nconst cat = createInstance(Cat); // Cat\ncat.meow();\n\n// Factory with constructor arguments\nfunction createWithArgs<T, Args extends any[]>(\n  ctor: new (...args: Args) => T,\n  ...args: Args\n): T {\n  return new ctor(...args);\n}\n\nclass Person {\n  constructor(public name: string, public age: number) {}\n}\n\nconst person = createWithArgs(Person, 'Alice', 30); // Person\nconsole.log(person.name); // 'Alice'\n\n// Generic repository factory\ninterface Repository<T> {\n  findAll(): T[];\n  findById(id: number): T | undefined;\n  save(item: T): void;\n}\n\nfunction createRepository<T extends { id: number }>(): Repository<T> {\n  const items: T[] = [];\n  \n  return {\n    findAll: () => [...items],\n    findById: (id) => items.find(item => item.id === id),\n    save: (item) => items.push(item)\n  };\n}\n\ninterface Todo {\n  id: number;\n  title: string;\n  done: boolean;\n}\n\nconst todoRepo = createRepository<Todo>();\ntodoRepo.save({ id: 1, title: 'Learn generics', done: true });",
      "explanation": "Generic factories create properly typed instances and repositories for any entity type."
    },
    {
      "title": "Generic Event System",
      "description": "Type-safe event emitter using generics",
      "code": "// Type-safe event emitter\ntype EventMap = {\n  userLoggedIn: { userId: number; timestamp: Date };\n  userLoggedOut: { userId: number };\n  itemPurchased: { itemId: number; quantity: number; price: number };\n};\n\nclass TypedEventEmitter<Events extends Record<string, any>> {\n  private listeners: {\n    [K in keyof Events]?: ((data: Events[K]) => void)[];\n  } = {};\n\n  on<K extends keyof Events>(event: K, listener: (data: Events[K]) => void): void {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event]!.push(listener);\n  }\n\n  emit<K extends keyof Events>(event: K, data: Events[K]): void {\n    const eventListeners = this.listeners[event];\n    if (eventListeners) {\n      eventListeners.forEach(listener => listener(data));\n    }\n  }\n\n  off<K extends keyof Events>(event: K, listener: (data: Events[K]) => void): void {\n    const eventListeners = this.listeners[event];\n    if (eventListeners) {\n      const index = eventListeners.indexOf(listener);\n      if (index > -1) {\n        eventListeners.splice(index, 1);\n      }\n    }\n  }\n}\n\n// Usage\nconst emitter = new TypedEventEmitter<EventMap>();\n\nemitter.on('userLoggedIn', (data) => {\n  // TypeScript knows: data is { userId: number; timestamp: Date }\n  console.log(`User ${data.userId} logged in at ${data.timestamp}`);\n});\n\nemitter.on('itemPurchased', (data) => {\n  // TypeScript knows: data is { itemId: number; quantity: number; price: number }\n  console.log(`Item ${data.itemId}: ${data.quantity} x $${data.price}`);\n});\n\nemitter.emit('userLoggedIn', { userId: 1, timestamp: new Date() });\nemitter.emit('itemPurchased', { itemId: 101, quantity: 2, price: 29.99 });\n\n// Type errors caught at compile time:\n// emitter.emit('userLoggedIn', { userId: 'invalid' }); // ✗ Error\n// emitter.emit('unknownEvent', {});                     // ✗ Error",
      "explanation": "Generic event emitters provide full type safety for event names and their payloads."
    },
    {
      "title": "Generic HTTP Client",
      "description": "Type-safe API client using generics",
      "code": "// Generic fetch wrapper\nasync function fetchJson<T>(url: string, options?: RequestInit): Promise<T> {\n  const response = await fetch(url, options);\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n// Generic CRUD client\nclass ApiClient<T extends { id: number }> {\n  constructor(private baseUrl: string) {}\n\n  async getAll(): Promise<T[]> {\n    return fetchJson<T[]>(this.baseUrl);\n  }\n\n  async getById(id: number): Promise<T> {\n    return fetchJson<T>(`${this.baseUrl}/${id}`);\n  }\n\n  async create(item: Omit<T, 'id'>): Promise<T> {\n    return fetchJson<T>(this.baseUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(item)\n    });\n  }\n\n  async update(id: number, updates: Partial<T>): Promise<T> {\n    return fetchJson<T>(`${this.baseUrl}/${id}`, {\n      method: 'PATCH',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(updates)\n    });\n  }\n\n  async delete(id: number): Promise<void> {\n    await fetch(`${this.baseUrl}/${id}`, { method: 'DELETE' });\n  }\n}\n\n// Usage\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface Post {\n  id: number;\n  title: string;\n  content: string;\n  authorId: number;\n}\n\nconst userApi = new ApiClient<User>('/api/users');\nconst postApi = new ApiClient<Post>('/api/posts');\n\n// Fully typed API calls\nconst users = await userApi.getAll();        // User[]\nconst user = await userApi.getById(1);       // User\nconst newUser = await userApi.create({       // User\n  name: 'Alice',\n  email: 'alice@example.com'\n});\n\nconst posts = await postApi.getAll();        // Post[]\nconst updatedPost = await postApi.update(1, { title: 'New Title' }); // Post",
      "explanation": "Generic API clients provide type-safe CRUD operations for any entity type."
    }
  ]
}
