{
  "id": "examples-functions",
  "title": "Functions Examples",
  "description": "Practical examples demonstrating typed functions in TypeScript",
  "examples": [
    {
      "title": "Calculator Functions",
      "description": "Basic arithmetic functions with proper types",
      "code": "// Basic typed functions\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\nfunction subtract(a: number, b: number): number {\n  return a - b;\n}\n\nfunction multiply(a: number, b: number): number {\n  return a * b;\n}\n\nfunction divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n  return a / b;\n}\n\n// Usage\nconsole.log(add(10, 5));       // 15\nconsole.log(subtract(10, 5));  // 5\nconsole.log(multiply(10, 5));  // 50\nconsole.log(divide(10, 5));    // 2\n\n// TypeScript catches errors at compile time:\n// add('10', 5);  // ✗ Error: string not assignable to number",
      "explanation": "Each function explicitly declares parameter types and return types, making the code self-documenting."
    },
    {
      "title": "Optional and Default Parameters",
      "description": "Flexible function parameters for real-world use",
      "code": "// User greeting with optional title\nfunction greetUser(\n  name: string,\n  title?: string,           // Optional parameter\n  greeting: string = 'Hello' // Default parameter\n): string {\n  const fullName = title ? `${title} ${name}` : name;\n  return `${greeting}, ${fullName}!`;\n}\n\nconsole.log(greetUser('Alice'));                // \"Hello, Alice!\"\nconsole.log(greetUser('Smith', 'Dr.'));         // \"Hello, Dr. Smith!\"\nconsole.log(greetUser('Bob', undefined, 'Hi')); // \"Hi, Bob!\"\nconsole.log(greetUser('Jane', 'Ms.', 'Welcome')); // \"Welcome, Ms. Jane!\"\n\n// API request with defaults\nfunction fetchData(\n  url: string,\n  method: string = 'GET',\n  timeout: number = 5000,\n  headers: Record<string, string> = {}\n): void {\n  console.log(`${method} ${url} (timeout: ${timeout}ms)`);\n  console.log('Headers:', headers);\n}\n\nfetchData('/api/users');                         // Uses all defaults\nfetchData('/api/users', 'POST');                 // Custom method\nfetchData('/api/users', 'GET', 10000);           // Custom timeout\nfetchData('/api/users', 'POST', 5000, { 'Content-Type': 'application/json' });",
      "explanation": "Optional parameters use '?' and can be undefined. Default parameters have fallback values."
    },
    {
      "title": "Rest Parameters for Variable Arguments",
      "description": "Functions that accept any number of arguments",
      "code": "// Sum any number of values\nfunction sum(...numbers: number[]): number {\n  return numbers.reduce((total, n) => total + n, 0);\n}\n\nconsole.log(sum(1, 2, 3));           // 6\nconsole.log(sum(10, 20, 30, 40));    // 100\nconsole.log(sum(5));                 // 5\nconsole.log(sum());                  // 0\n\n// Log messages with prefix\nfunction log(level: string, ...messages: string[]): void {\n  const timestamp = new Date().toISOString();\n  messages.forEach(msg => {\n    console.log(`[${timestamp}] [${level}] ${msg}`);\n  });\n}\n\nlog('INFO', 'Server started', 'Listening on port 3000');\nlog('ERROR', 'Connection failed');\n\n// Build SQL query with parameters\nfunction query(sql: string, ...params: (string | number | boolean)[]): string {\n  let result = sql;\n  params.forEach((param, index) => {\n    const value = typeof param === 'string' ? `'${param}'` : String(param);\n    result = result.replace(`$${index + 1}`, value);\n  });\n  return result;\n}\n\nconsole.log(query('SELECT * FROM users WHERE id = $1', 42));\n// \"SELECT * FROM users WHERE id = 42\"\nconsole.log(query('INSERT INTO users (name, age) VALUES ($1, $2)', 'Alice', 30));\n// \"INSERT INTO users (name, age) VALUES ('Alice', 30)\"",
      "explanation": "Rest parameters collect all extra arguments into an array for flexible function signatures."
    },
    {
      "title": "Arrow Functions",
      "description": "Concise function syntax for modern TypeScript",
      "code": "// Simple arrow functions\nconst double = (n: number): number => n * 2;\nconst greet = (name: string): string => `Hello, ${name}!`;\nconst isEven = (n: number): boolean => n % 2 === 0;\n\nconsole.log(double(5));       // 10\nconsole.log(greet('Alice'));  // \"Hello, Alice!\"\nconsole.log(isEven(4));       // true\n\n// Arrow functions with array methods\nconst numbers = [1, 2, 3, 4, 5];\n\nconst doubled = numbers.map(n => n * 2);           // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(n => n % 2 === 0);    // [2, 4]\nconst sum = numbers.reduce((a, b) => a + b, 0);    // 15\nconst found = numbers.find(n => n > 3);            // 4\n\n// Multi-line arrow function\nconst processUser = (name: string, age: number): object => {\n  const isAdult = age >= 18;\n  const greeting = `Hello, ${name}!`;\n  return {\n    name,\n    age,\n    isAdult,\n    greeting\n  };\n};\n\nconsole.log(processUser('Alice', 25));\n// { name: 'Alice', age: 25, isAdult: true, greeting: 'Hello, Alice!' }",
      "explanation": "Arrow functions provide concise syntax, especially useful for callbacks and simple operations."
    },
    {
      "title": "Function Types and Callbacks",
      "description": "Using functions as parameters and return values",
      "code": "// Define a function type\ntype MathOperation = (a: number, b: number) => number;\n\n// Functions that match the type\nconst add: MathOperation = (a, b) => a + b;\nconst subtract: MathOperation = (a, b) => a - b;\nconst multiply: MathOperation = (a, b) => a * b;\n\n// Higher-order function that accepts a function\nfunction calculate(\n  operation: MathOperation,\n  a: number,\n  b: number\n): number {\n  return operation(a, b);\n}\n\nconsole.log(calculate(add, 10, 5));       // 15\nconsole.log(calculate(subtract, 10, 5));  // 5\nconsole.log(calculate(multiply, 10, 5));  // 50\n\n// Callback pattern\ntype Callback<T> = (error: Error | null, result?: T) => void;\n\nfunction fetchUser(id: number, callback: Callback<{ name: string }>) {\n  setTimeout(() => {\n    if (id <= 0) {\n      callback(new Error('Invalid ID'));\n    } else {\n      callback(null, { name: 'Alice' });\n    }\n  }, 100);\n}\n\nfetchUser(1, (error, user) => {\n  if (error) {\n    console.error(error.message);\n  } else {\n    console.log(`User: ${user?.name}`);\n  }\n});",
      "explanation": "Function types define the shape of callbacks and enable higher-order functions."
    },
    {
      "title": "Function Overloads",
      "description": "Multiple function signatures for different use cases",
      "code": "// Overloaded function for formatting values\nfunction format(value: string): string;\nfunction format(value: number): string;\nfunction format(value: Date): string;\nfunction format(value: string | number | Date): string {\n  if (typeof value === 'string') {\n    return value.trim().toUpperCase();\n  } else if (typeof value === 'number') {\n    return value.toLocaleString('en-US', { minimumFractionDigits: 2 });\n  } else {\n    return value.toISOString().split('T')[0];\n  }\n}\n\nconsole.log(format('  hello world  ')); // \"HELLO WORLD\"\nconsole.log(format(1234567.89));         // \"1,234,567.89\"\nconsole.log(format(new Date()));         // \"2024-12-23\"\n\n// Overloaded createElement function\nfunction createElement(tag: 'a'): HTMLAnchorElement;\nfunction createElement(tag: 'button'): HTMLButtonElement;\nfunction createElement(tag: 'input'): HTMLInputElement;\nfunction createElement(tag: string): HTMLElement;\nfunction createElement(tag: string): HTMLElement {\n  return document.createElement(tag);\n}\n\nconst link = createElement('a');     // HTMLAnchorElement\nconst button = createElement('button'); // HTMLButtonElement\nconst input = createElement('input');   // HTMLInputElement\nconst div = createElement('div');     // HTMLElement\n\n// TypeScript knows the exact return type based on the argument!\nlink.href = 'https://example.com';  // ✓ href exists on HTMLAnchorElement\nbutton.disabled = true;             // ✓ disabled exists on HTMLButtonElement\ninput.value = 'test';               // ✓ value exists on HTMLInputElement",
      "explanation": "Overloads let you define multiple signatures with specific return types based on input types."
    },
    {
      "title": "Async Functions",
      "description": "Typed asynchronous functions with Promises",
      "code": "// Basic async function with return type\nasync function fetchUser(id: number): Promise<{ name: string; email: string }> {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) {\n    throw new Error('User not found');\n  }\n  return response.json();\n}\n\n// Using the async function\nasync function main() {\n  try {\n    const user = await fetchUser(1);\n    console.log(user.name);  // TypeScript knows 'name' exists\n    console.log(user.email); // TypeScript knows 'email' exists\n  } catch (error) {\n    console.error('Failed to fetch user');\n  }\n}\n\n// Async function with multiple awaits\nasync function getUserWithPosts(userId: number): Promise<{\n  user: { name: string };\n  posts: { title: string }[];\n}> {\n  const [userResponse, postsResponse] = await Promise.all([\n    fetch(`/api/users/${userId}`),\n    fetch(`/api/users/${userId}/posts`)\n  ]);\n  \n  const user = await userResponse.json();\n  const posts = await postsResponse.json();\n  \n  return { user, posts };\n}\n\n// Promise.all with typed array\nasync function fetchMultipleUsers(ids: number[]): Promise<{ name: string }[]> {\n  const promises = ids.map(id => \n    fetch(`/api/users/${id}`).then(r => r.json())\n  );\n  return Promise.all(promises);\n}",
      "explanation": "Async functions return Promises. TypeScript ensures the return type matches what's actually returned."
    },
    {
      "title": "Generic Functions",
      "description": "Functions that work with any type while maintaining type safety",
      "code": "// Generic identity function\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nconst num = identity(42);        // num: number\nconst str = identity('hello');   // str: string\nconst arr = identity([1, 2, 3]); // arr: number[]\n\n// Generic array utilities\nfunction first<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nfunction reverse<T>(arr: T[]): T[] {\n  return [...arr].reverse();\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nconsole.log(first(numbers));   // 1 (number | undefined)\nconsole.log(last(numbers));    // 5 (number | undefined)\nconsole.log(reverse(numbers)); // [5, 4, 3, 2, 1]\n\n// Generic with constraints\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { name: 'Alice', age: 30, email: 'alice@example.com' };\nconst userName = getProperty(user, 'name');  // string\nconst userAge = getProperty(user, 'age');    // number\n// getProperty(user, 'invalid');             // ✗ Error: 'invalid' not a key",
      "explanation": "Generics let you write reusable functions that preserve type information across different types."
    }
  ]
}
