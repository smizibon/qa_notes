{
  "id": "examples-utility-types",
  "title": "Utility Types - Practical Examples",
  "description": "Real-world examples of TypeScript utility types for transforming and manipulating types",
  "examples": [
    {
      "title": "CRUD Operations with Utility Types",
      "code": "interface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Create: Omit auto-generated fields\ntype CreateUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;\n\n// Read: Omit sensitive fields\ntype PublicUser = Omit<User, 'password'>;\n\n// Update: Partial + Omit (can't change id or timestamps)\ntype UpdateUserInput = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;\n\n// List: Pick only preview fields\ntype UserListItem = Pick<User, 'id' | 'name' | 'email'>;\n\nclass UserService {\n  create(input: CreateUserInput): PublicUser {\n    const user: User = {\n      ...input,\n      id: Math.random(),\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    // Don't return password\n    const { password, ...publicUser } = user;\n    return publicUser;\n  }\n  \n  update(id: number, input: UpdateUserInput): PublicUser {\n    const user = this.findById(id);\n    const updated = {\n      ...user,\n      ...input,\n      updatedAt: new Date()\n    };\n    const { password, ...publicUser } = updated;\n    return publicUser;\n  }\n  \n  list(): UserListItem[] {\n    return this.findAll().map(({ id, name, email }) => ({\n      id, name, email\n    }));\n  }\n  \n  private findById(id: number): User { /* ... */ return {} as User; }\n  private findAll(): User[] { /* ... */ return []; }\n}\n\n// Usage\nconst service = new UserService();\n\n// Create - must provide name, email, password\nconst newUser = service.create({\n  name: 'Alice',\n  email: 'alice@example.com',\n  password: 'securepassword'\n});\n\n// Update - can provide any subset\nservice.update(1, { name: 'Alice Smith' });  // Just name\nservice.update(1, { email: 'new@email.com', password: 'newpass' });  // Multiple",
      "explanation": "Utility types create perfect CRUD operation signatures - each operation gets exactly the fields it should accept."
    },
    {
      "title": "Record for Lookup Tables",
      "code": "// HTTP Status codes lookup\ntype StatusCode = 200 | 201 | 400 | 401 | 404 | 500;\n\ninterface StatusInfo {\n  message: string;\n  category: 'success' | 'error';\n}\n\nconst statusMessages: Record<StatusCode, StatusInfo> = {\n  200: { message: 'OK', category: 'success' },\n  201: { message: 'Created', category: 'success' },\n  400: { message: 'Bad Request', category: 'error' },\n  401: { message: 'Unauthorized', category: 'error' },\n  404: { message: 'Not Found', category: 'error' },\n  500: { message: 'Internal Server Error', category: 'error' }\n};\n\n// Country code to country name\ntype CountryCode = 'US' | 'UK' | 'CA' | 'AU' | 'DE' | 'FR';\n\nconst countries: Record<CountryCode, string> = {\n  US: 'United States',\n  UK: 'United Kingdom',\n  CA: 'Canada',\n  AU: 'Australia',\n  DE: 'Germany',\n  FR: 'France'\n};\n\n// Feature flags\ntype Feature = 'darkMode' | 'newDashboard' | 'betaFeatures' | 'advancedSearch';\n\nconst featureFlags: Record<Feature, boolean> = {\n  darkMode: true,\n  newDashboard: false,\n  betaFeatures: false,\n  advancedSearch: true\n};\n\nfunction isFeatureEnabled(feature: Feature): boolean {\n  return featureFlags[feature];\n}\n\n// Pricing tiers\ntype Tier = 'free' | 'pro' | 'enterprise';\n\ninterface TierConfig {\n  price: number;\n  maxUsers: number;\n  features: string[];\n}\n\nconst pricing: Record<Tier, TierConfig> = {\n  free: { price: 0, maxUsers: 5, features: ['basic'] },\n  pro: { price: 49, maxUsers: 50, features: ['basic', 'advanced', 'priority'] },\n  enterprise: { price: 199, maxUsers: Infinity, features: ['basic', 'advanced', 'priority', 'dedicated'] }\n};",
      "explanation": "Record<K, V> with union key types ensures all keys are present - TypeScript will error if you forget one."
    },
    {
      "title": "Extract and Exclude for Union Filtering",
      "code": "// Original events union\ntype AppEvent =\n  | { type: 'login'; userId: string }\n  | { type: 'logout'; userId: string }\n  | { type: 'purchase'; productId: string; amount: number }\n  | { type: 'view'; pageId: string }\n  | { type: 'error'; message: string; code: number };\n\n// Extract only user-related events\ntype UserEvent = Extract<AppEvent, { userId: string }>;\n// = { type: 'login'; userId: string } | { type: 'logout'; userId: string }\n\n// Extract error events\ntype ErrorEvent = Extract<AppEvent, { type: 'error' }>;\n// = { type: 'error'; message: string; code: number }\n\n// Exclude error events for analytics\ntype AnalyticsEvent = Exclude<AppEvent, { type: 'error' }>;\n// = login | logout | purchase | view\n\nfunction trackAnalytics(event: AnalyticsEvent): void {\n  console.log(`Tracking: ${event.type}`);\n}\n\nfunction handleError(event: ErrorEvent): void {\n  console.error(`Error ${event.code}: ${event.message}`);\n}\n\n// Type-safe event routing\nfunction routeEvent(event: AppEvent): void {\n  if (event.type === 'error') {\n    handleError(event);\n  } else {\n    trackAnalytics(event);\n  }\n}\n\n// Extract specific event types by type\ntype LoginEvent = Extract<AppEvent, { type: 'login' }>;\ntype PurchaseEvent = Extract<AppEvent, { type: 'purchase' }>;\n\n// Handler registry using Record\ntype EventHandler<T> = (event: T) => void;\n\nconst handlers: {\n  login: EventHandler<LoginEvent>;\n  purchase: EventHandler<PurchaseEvent>;\n} = {\n  login: (e) => console.log(`User ${e.userId} logged in`),\n  purchase: (e) => console.log(`Purchased ${e.productId} for $${e.amount}`)\n};",
      "explanation": "Extract and Exclude filter union types to create subsets - perfect for event handling systems."
    },
    {
      "title": "ReturnType and Parameters for Wrappers",
      "code": "// Original API function\nasync function fetchUsers(\n  page: number,\n  limit: number,\n  filter?: string\n): Promise<{ users: User[]; total: number }> {\n  const response = await fetch(`/api/users?page=${page}&limit=${limit}`);\n  return response.json();\n}\n\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Extract types from the function\ntype FetchUsersParams = Parameters<typeof fetchUsers>;\n// = [page: number, limit: number, filter?: string]\n\ntype FetchUsersResult = ReturnType<typeof fetchUsers>;\n// = Promise<{ users: User[]; total: number }>\n\ntype FetchUsersData = Awaited<ReturnType<typeof fetchUsers>>;\n// = { users: User[]; total: number }\n\n// Create a caching wrapper with same signature\nconst cache = new Map<string, FetchUsersData>();\n\nasync function cachedFetchUsers(\n  ...args: FetchUsersParams\n): FetchUsersResult {\n  const key = JSON.stringify(args);\n  \n  if (cache.has(key)) {\n    return cache.get(key)!;\n  }\n  \n  const result = await fetchUsers(...args);\n  cache.set(key, result);\n  return result;\n}\n\n// Create a logging wrapper\nfunction withLogging<T extends (...args: any[]) => any>(\n  fn: T,\n  name: string\n): (...args: Parameters<T>) => ReturnType<T> {\n  return function(...args: Parameters<T>): ReturnType<T> {\n    console.log(`[${name}] Called with:`, args);\n    const start = Date.now();\n    const result = fn(...args);\n    \n    // Handle promises\n    if (result instanceof Promise) {\n      return result.then(value => {\n        console.log(`[${name}] Completed in ${Date.now() - start}ms`);\n        return value;\n      }) as ReturnType<T>;\n    }\n    \n    console.log(`[${name}] Completed in ${Date.now() - start}ms`);\n    return result;\n  };\n}\n\nconst loggedFetchUsers = withLogging(fetchUsers, 'fetchUsers');",
      "explanation": "Parameters and ReturnType preserve function signatures when creating wrappers, decorators, or middleware."
    },
    {
      "title": "NonNullable for Safe Data Access",
      "code": "interface UserProfile {\n  id: number;\n  name: string;\n  email: string | null;\n  phone: string | null | undefined;\n  address?: {\n    street: string;\n    city: string;\n    country: string;\n  };\n}\n\n// Remove null/undefined from a type\ntype DefiniteEmail = NonNullable<UserProfile['email']>;\n// = string\n\ntype DefinitePhone = NonNullable<UserProfile['phone']>;\n// = string\n\n// Helper function using NonNullable\nfunction assertDefined<T>(\n  value: T,\n  name: string\n): asserts value is NonNullable<T> {\n  if (value === null || value === undefined) {\n    throw new Error(`${name} must be defined`);\n  }\n}\n\nfunction processUser(user: UserProfile): void {\n  // email is string | null here\n  console.log(user.email?.toUpperCase());\n  \n  // After assertion, email is string\n  assertDefined(user.email, 'email');\n  console.log(user.email.toUpperCase()); // Safe!\n}\n\n// Filter helper with proper typing\nfunction filterDefined<T>(arr: (T | null | undefined)[]): NonNullable<T>[] {\n  return arr.filter((item): item is NonNullable<T> => \n    item !== null && item !== undefined\n  );\n}\n\nconst emails: (string | null | undefined)[] = [\n  'alice@example.com',\n  null,\n  'bob@example.com',\n  undefined,\n  'charlie@example.com'\n];\n\nconst definedEmails = filterDefined(emails);\n// Type: string[]\nconsole.log(definedEmails); // ['alice@...', 'bob@...', 'charlie@...']",
      "explanation": "NonNullable removes null and undefined from types - essential for safely accessing optional data."
    },
    {
      "title": "Readonly for Immutable State",
      "code": "interface AppState {\n  user: {\n    id: number;\n    name: string;\n    preferences: {\n      theme: 'light' | 'dark';\n      notifications: boolean;\n    };\n  } | null;\n  cart: {\n    items: Array<{ productId: number; quantity: number }>;\n    total: number;\n  };\n  isLoading: boolean;\n}\n\n// Deep readonly type (recursive)\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object\n    ? DeepReadonly<T[P]>\n    : T[P];\n};\n\ntype ImmutableState = DeepReadonly<AppState>;\n\n// State management with immutability\nclass Store {\n  private state: AppState = {\n    user: null,\n    cart: { items: [], total: 0 },\n    isLoading: false\n  };\n  \n  // Return readonly state to prevent external mutations\n  getState(): Readonly<AppState> {\n    return this.state;\n  }\n  \n  // Only update through actions\n  setUser(user: AppState['user']): void {\n    this.state = {\n      ...this.state,\n      user\n    };\n  }\n  \n  addToCart(productId: number, quantity: number): void {\n    const newItem = { productId, quantity };\n    this.state = {\n      ...this.state,\n      cart: {\n        items: [...this.state.cart.items, newItem],\n        total: this.calculateTotal([...this.state.cart.items, newItem])\n      }\n    };\n  }\n  \n  private calculateTotal(items: AppState['cart']['items']): number {\n    return items.reduce((sum, item) => sum + item.quantity * 10, 0);\n  }\n}\n\nconst store = new Store();\nconst state = store.getState();\n\n// These would cause TypeScript errors if we tried:\n// state.isLoading = true;  // Error: readonly\n// state.cart.items.push({...});  // Error: readonly array\n\n// Must use store methods instead\nstore.addToCart(123, 2);",
      "explanation": "Readonly prevents mutations to state objects - essential for predictable state management."
    },
    {
      "title": "Combining Utility Types for Forms",
      "code": "interface Product {\n  id: number;\n  name: string;\n  description: string;\n  price: number;\n  category: 'electronics' | 'clothing' | 'food' | 'other';\n  inStock: boolean;\n  imageUrl: string | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Form for creating product - omit auto-generated, require most\ntype CreateProductForm = Required<\n  Omit<Product, 'id' | 'createdAt' | 'updatedAt' | 'imageUrl'>\n> & {\n  imageUrl?: string | null; // Image is optional\n};\n\n// Form for editing - all fields optional except id\ntype EditProductForm = Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>;\n\n// Display type - readonly, without internal fields\ntype ProductDisplay = Readonly<Omit<Product, 'createdAt' | 'updatedAt'>>;\n\n// Validation result\ntype FormErrors<T> = Partial<Record<keyof T, string>>;\n\nfunction validateCreateForm(form: CreateProductForm): FormErrors<CreateProductForm> {\n  const errors: FormErrors<CreateProductForm> = {};\n  \n  if (!form.name || form.name.length < 3) {\n    errors.name = 'Name must be at least 3 characters';\n  }\n  \n  if (!form.description || form.description.length < 10) {\n    errors.description = 'Description must be at least 10 characters';\n  }\n  \n  if (form.price <= 0) {\n    errors.price = 'Price must be positive';\n  }\n  \n  return errors;\n}\n\n// Usage\nconst createForm: CreateProductForm = {\n  name: 'Laptop',\n  description: 'High-performance laptop for developers',\n  price: 999.99,\n  category: 'electronics',\n  inStock: true,\n  imageUrl: 'https://example.com/laptop.jpg'\n};\n\nconst errors = validateCreateForm(createForm);\nif (Object.keys(errors).length === 0) {\n  console.log('Form is valid!');\n} else {\n  console.log('Errors:', errors);\n}",
      "explanation": "Combining utility types creates precise form types - create/edit/display all derived from one base type."
    },
    {
      "title": "Utility Types for API Responses",
      "code": "// Base API response wrapper\ntype ApiResponse<T> = \n  | { status: 'success'; data: T; timestamp: Date }\n  | { status: 'error'; error: string; code: number; timestamp: Date }\n  | { status: 'loading' };\n\n// Extract just the success data type\ntype ExtractData<R> = R extends { status: 'success'; data: infer D } ? D : never;\n\n// Resource types\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\n// API response types\ntype UserResponse = ApiResponse<User>;\ntype UsersResponse = ApiResponse<User[]>;\ntype ProductResponse = ApiResponse<Product>;\n\n// Paginated response\ntype Paginated<T> = {\n  items: T[];\n  page: number;\n  pageSize: number;\n  totalItems: number;\n  totalPages: number;\n};\n\ntype PaginatedUsersResponse = ApiResponse<Paginated<User>>;\n\n// Handler types using ReturnType\nasync function getUser(id: number): Promise<UserResponse> {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    const data = await response.json();\n    return { status: 'success', data, timestamp: new Date() };\n  } catch (e) {\n    return { \n      status: 'error', \n      error: 'Failed to fetch user',\n      code: 500,\n      timestamp: new Date()\n    };\n  }\n}\n\n// Extract the data type from the response\ntype UserData = ExtractData<Awaited<ReturnType<typeof getUser>>>;\n// = User\n\n// Utility to unwrap successful responses\nfunction unwrap<T>(response: ApiResponse<T>): T {\n  if (response.status === 'success') {\n    return response.data;\n  }\n  if (response.status === 'error') {\n    throw new Error(`API Error ${response.code}: ${response.error}`);\n  }\n  throw new Error('Response still loading');\n}\n\n// Usage\nasync function displayUser(id: number): Promise<void> {\n  const response = await getUser(id);\n  const user = unwrap(response); // Type: User\n  console.log(`Hello, ${user.name}!`);\n}",
      "explanation": "Utility types combined with conditional types create type-safe API response handling."
    }
  ]
}
