{
  "id": "examples-enums",
  "title": "Enums - Practical Examples",
  "description": "Real-world examples of TypeScript enums for named constants and type-safe selections",
  "examples": [
    {
      "title": "Numeric Enum - HTTP Status Codes",
      "code": "enum HttpStatus {\n  OK = 200,\n  Created = 201,\n  BadRequest = 400,\n  Unauthorized = 401,\n  NotFound = 404,\n  ServerError = 500\n}\n\ninterface ApiResponse<T> {\n  status: HttpStatus;\n  data?: T;\n  error?: string;\n}\n\nfunction handleResponse<T>(response: ApiResponse<T>): T | null {\n  switch (response.status) {\n    case HttpStatus.OK:\n    case HttpStatus.Created:\n      console.log('Success!');\n      return response.data ?? null;\n    case HttpStatus.NotFound:\n      console.error('Resource not found');\n      return null;\n    case HttpStatus.Unauthorized:\n      console.error('Please login');\n      return null;\n    case HttpStatus.ServerError:\n      console.error('Server error:', response.error);\n      return null;\n    default:\n      const _exhaustive: never = response.status;\n      throw new Error(`Unhandled status: ${_exhaustive}`);\n  }\n}\n\n// Usage\nconst successResponse: ApiResponse<{ name: string }> = {\n  status: HttpStatus.OK,\n  data: { name: 'John' }\n};\n\nconst result = handleResponse(successResponse);\nconsole.log(result); // { name: 'John' }",
      "explanation": "Using numeric enums for HTTP status codes with exhaustive switch pattern ensures all cases are handled."
    },
    {
      "title": "String Enum - Order Status Workflow",
      "code": "enum OrderStatus {\n  Pending = 'PENDING',\n  Confirmed = 'CONFIRMED',\n  Processing = 'PROCESSING',\n  Shipped = 'SHIPPED',\n  Delivered = 'DELIVERED',\n  Cancelled = 'CANCELLED'\n}\n\ninterface Order {\n  id: string;\n  status: OrderStatus;\n  updatedAt: Date;\n}\n\nconst statusTransitions: Record<OrderStatus, OrderStatus[]> = {\n  [OrderStatus.Pending]: [OrderStatus.Confirmed, OrderStatus.Cancelled],\n  [OrderStatus.Confirmed]: [OrderStatus.Processing, OrderStatus.Cancelled],\n  [OrderStatus.Processing]: [OrderStatus.Shipped, OrderStatus.Cancelled],\n  [OrderStatus.Shipped]: [OrderStatus.Delivered],\n  [OrderStatus.Delivered]: [],\n  [OrderStatus.Cancelled]: []\n};\n\nfunction canTransition(from: OrderStatus, to: OrderStatus): boolean {\n  return statusTransitions[from].includes(to);\n}\n\nfunction updateOrderStatus(order: Order, newStatus: OrderStatus): Order {\n  if (!canTransition(order.status, newStatus)) {\n    throw new Error(\n      `Invalid transition from ${order.status} to ${newStatus}`\n    );\n  }\n  return { ...order, status: newStatus, updatedAt: new Date() };\n}\n\n// Usage\nlet order: Order = {\n  id: 'ORD-001',\n  status: OrderStatus.Pending,\n  updatedAt: new Date()\n};\n\norder = updateOrderStatus(order, OrderStatus.Confirmed);\nconsole.log(order.status); // 'CONFIRMED'\n\n// This would throw an error:\n// order = updateOrderStatus(order, OrderStatus.Delivered);",
      "explanation": "String enums are perfect for workflow states. The status transition map ensures valid state changes."
    },
    {
      "title": "Const Enum - Performance-Optimized Keys",
      "code": "const enum CacheKey {\n  Users = 'cache:users',\n  Products = 'cache:products',\n  Orders = 'cache:orders',\n  Settings = 'cache:settings'\n}\n\nconst enum CacheTTL {\n  Short = 60,        // 1 minute\n  Medium = 300,      // 5 minutes\n  Long = 3600,       // 1 hour\n  Forever = 86400    // 24 hours\n}\n\nclass CacheService {\n  private cache = new Map<string, { value: unknown; expiresAt: number }>();\n\n  set(key: CacheKey, value: unknown, ttl: CacheTTL): void {\n    this.cache.set(key, {\n      value,\n      expiresAt: Date.now() + ttl * 1000\n    });\n  }\n\n  get<T>(key: CacheKey): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return null;\n    }\n    return entry.value as T;\n  }\n}\n\n// Usage - const enums are inlined at compile time\nconst cache = new CacheService();\ncache.set(CacheKey.Users, [{ id: 1, name: 'John' }], CacheTTL.Medium);\n\nconst users = cache.get<Array<{ id: number; name: string }>>(CacheKey.Users);\nconsole.log(users);\n\n// Compiles to:\n// cache.set('cache:users', [{ id: 1, name: 'John' }], 300);",
      "explanation": "Const enums are completely removed at compile time - values are inlined directly for zero runtime overhead."
    },
    {
      "title": "Enum with Discriminated Union",
      "code": "enum PaymentMethod {\n  CreditCard = 'CREDIT_CARD',\n  PayPal = 'PAYPAL',\n  BankTransfer = 'BANK_TRANSFER',\n  Crypto = 'CRYPTO'\n}\n\ninterface CreditCardPayment {\n  method: PaymentMethod.CreditCard;\n  cardNumber: string;\n  cvv: string;\n  expiryDate: string;\n}\n\ninterface PayPalPayment {\n  method: PaymentMethod.PayPal;\n  email: string;\n}\n\ninterface BankTransferPayment {\n  method: PaymentMethod.BankTransfer;\n  accountNumber: string;\n  routingNumber: string;\n}\n\ninterface CryptoPayment {\n  method: PaymentMethod.Crypto;\n  walletAddress: string;\n  network: 'ETH' | 'BTC' | 'SOL';\n}\n\ntype Payment = CreditCardPayment | PayPalPayment | BankTransferPayment | CryptoPayment;\n\nfunction processPayment(payment: Payment, amount: number): void {\n  console.log(`Processing $${amount} via ${payment.method}`);\n  \n  switch (payment.method) {\n    case PaymentMethod.CreditCard:\n      // TypeScript knows payment is CreditCardPayment here\n      console.log(`Charging card ending in ${payment.cardNumber.slice(-4)}`);\n      break;\n    case PaymentMethod.PayPal:\n      console.log(`Sending request to ${payment.email}`);\n      break;\n    case PaymentMethod.BankTransfer:\n      console.log(`Transferring to account ${payment.accountNumber}`);\n      break;\n    case PaymentMethod.Crypto:\n      console.log(`Sending to ${payment.walletAddress} on ${payment.network}`);\n      break;\n  }\n}\n\n// Usage\nconst creditCardPayment: Payment = {\n  method: PaymentMethod.CreditCard,\n  cardNumber: '4111111111111111',\n  cvv: '123',\n  expiryDate: '12/25'\n};\n\nprocessPayment(creditCardPayment, 99.99);",
      "explanation": "Using enum members as discriminators in union types enables powerful type narrowing in switch statements."
    },
    {
      "title": "Enum with Computed Values",
      "code": "enum FileSize {\n  KB = 1024,\n  MB = KB * 1024,\n  GB = MB * 1024,\n  TB = GB * 1024\n}\n\nenum BitFlag {\n  Read = 1 << 0,     // 1\n  Write = 1 << 1,    // 2\n  Execute = 1 << 2,  // 4\n  ReadWrite = Read | Write,  // 3\n  All = Read | Write | Execute  // 7\n}\n\nfunction formatFileSize(bytes: number): string {\n  if (bytes >= FileSize.TB) {\n    return `${(bytes / FileSize.TB).toFixed(2)} TB`;\n  } else if (bytes >= FileSize.GB) {\n    return `${(bytes / FileSize.GB).toFixed(2)} GB`;\n  } else if (bytes >= FileSize.MB) {\n    return `${(bytes / FileSize.MB).toFixed(2)} MB`;\n  } else {\n    return `${(bytes / FileSize.KB).toFixed(2)} KB`;\n  }\n}\n\nfunction checkPermission(flags: number, permission: BitFlag): boolean {\n  return (flags & permission) === permission;\n}\n\n// Usage\nconsole.log(formatFileSize(1536000000)); // '1.43 GB'\n\nconst userPermissions = BitFlag.ReadWrite;\nconsole.log(checkPermission(userPermissions, BitFlag.Read));    // true\nconsole.log(checkPermission(userPermissions, BitFlag.Write));   // true\nconsole.log(checkPermission(userPermissions, BitFlag.Execute)); // false",
      "explanation": "Enums can have computed values using expressions. Bit flags are a common use case for combining permissions."
    },
    {
      "title": "Iterating Over Enum Values",
      "code": "enum Color {\n  Red = 'RED',\n  Green = 'GREEN',\n  Blue = 'BLUE',\n  Yellow = 'YELLOW'\n}\n\n// Get all enum values (string enum)\nfunction getEnumValues<T extends Record<string, string>>(enumObj: T): string[] {\n  return Object.values(enumObj);\n}\n\n// Get all enum keys\nfunction getEnumKeys<T extends Record<string, string>>(enumObj: T): string[] {\n  return Object.keys(enumObj);\n}\n\nconsole.log(getEnumValues(Color)); // ['RED', 'GREEN', 'BLUE', 'YELLOW']\nconsole.log(getEnumKeys(Color));   // ['Red', 'Green', 'Blue', 'Yellow']\n\n// Create dropdown options from enum\nfunction createDropdownOptions<T extends Record<string, string>>(\n  enumObj: T\n): Array<{ label: string; value: string }> {\n  return Object.entries(enumObj).map(([key, value]) => ({\n    label: key.replace(/([A-Z])/g, ' $1').trim(), // Add spaces before capitals\n    value\n  }));\n}\n\nconst colorOptions = createDropdownOptions(Color);\nconsole.log(colorOptions);\n// [\n//   { label: 'Red', value: 'RED' },\n//   { label: 'Green', value: 'GREEN' },\n//   { label: 'Blue', value: 'BLUE' },\n//   { label: 'Yellow', value: 'YELLOW' }\n// ]",
      "explanation": "String enums can be iterated using Object.keys/values/entries to generate UI components dynamically."
    },
    {
      "title": "Modern Alternative - Union Types with Object",
      "code": "// Union type for type safety\ntype Theme = 'light' | 'dark' | 'system';\n\n// Const object for autocomplete and values\nconst Theme = {\n  Light: 'light',\n  Dark: 'dark',\n  System: 'system'\n} as const;\n\n// Satisfies ensures the object matches the union\nconst ThemeSafe = {\n  Light: 'light',\n  Dark: 'dark',\n  System: 'system'\n} as const satisfies Record<string, Theme>;\n\ninterface UserPreferences {\n  theme: Theme;\n  fontSize: number;\n}\n\nfunction applyTheme(theme: Theme): void {\n  document.body.classList.remove('light', 'dark');\n  \n  if (theme === Theme.System) {\n    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n    document.body.classList.add(prefersDark ? 'dark' : 'light');\n  } else {\n    document.body.classList.add(theme);\n  }\n}\n\n// Usage - works just like an enum!\nconst prefs: UserPreferences = {\n  theme: Theme.Dark,  // Autocomplete works!\n  fontSize: 14\n};\n\napplyTheme(prefs.theme);\n\n// Type is the actual string value 'dark'\nconsole.log(prefs.theme); // 'dark'",
      "explanation": "Modern TypeScript often uses union types with const objects instead of enums. This gives string values, type safety, and autocomplete."
    },
    {
      "title": "Enum in API Request/Response",
      "code": "enum TaskPriority {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n  Urgent = 'urgent'\n}\n\nenum TaskStatus {\n  Todo = 'todo',\n  InProgress = 'in_progress',\n  Review = 'review',\n  Done = 'done'\n}\n\ninterface Task {\n  id: string;\n  title: string;\n  priority: TaskPriority;\n  status: TaskStatus;\n}\n\ninterface CreateTaskRequest {\n  title: string;\n  priority?: TaskPriority;\n}\n\ninterface UpdateTaskRequest {\n  title?: string;\n  priority?: TaskPriority;\n  status?: TaskStatus;\n}\n\nasync function createTask(request: CreateTaskRequest): Promise<Task> {\n  const response = await fetch('/api/tasks', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      ...request,\n      priority: request.priority ?? TaskPriority.Medium,\n      status: TaskStatus.Todo\n    })\n  });\n  return response.json();\n}\n\nasync function updateTask(id: string, updates: UpdateTaskRequest): Promise<Task> {\n  const response = await fetch(`/api/tasks/${id}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates)\n  });\n  return response.json();\n}\n\n// Usage\nconst newTask = await createTask({\n  title: 'Review PR #123',\n  priority: TaskPriority.High\n});\n\nconst updatedTask = await updateTask(newTask.id, {\n  status: TaskStatus.InProgress\n});",
      "explanation": "String enums work seamlessly with JSON APIs - the values serialize exactly as expected."
    }
  ]
}
