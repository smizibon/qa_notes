{
  "id": "examples-quick-reference",
  "title": "Quick Reference - Essential TypeScript Snippets",
  "description": "Copy-paste ready TypeScript code snippets for everyday use",
  "examples": [
    {
      "title": "Essential Type Declarations",
      "code": "// === PRIMITIVES ===\nlet name: string = 'Alice';\nlet age: number = 30;\nlet isActive: boolean = true;\nlet nothing: null = null;\nlet empty: undefined = undefined;\nlet unique: symbol = Symbol('id');\nlet big: bigint = 100n;\n\n// === ARRAYS ===\nlet numbers: number[] = [1, 2, 3];\nlet strings: Array<string> = ['a', 'b', 'c'];\nlet mixed: (string | number)[] = [1, 'two', 3];\n\n// === TUPLES ===\nlet tuple: [string, number] = ['Alice', 30];\nlet labeledTuple: [name: string, age: number] = ['Alice', 30];\n\n// === SPECIAL TYPES ===\nlet anything: any = 'risky';          // Avoid if possible\nlet unknown1: unknown = 'safer';       // Must narrow before use\nlet never1: never;                     // Never returns\nfunction fail(): never { throw new Error(); }\n\n// === OBJECT TYPE ===\nlet user: { name: string; age: number } = {\n  name: 'Alice',\n  age: 30\n};",
      "explanation": "Core type annotations you'll use every day. Prefer explicit types for function signatures, let inference work for variable assignments."
    },
    {
      "title": "Function Signatures",
      "code": "// === BASIC FUNCTION ===\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\n// === ARROW FUNCTION ===\nconst add = (a: number, b: number): number => a + b;\n\n// === OPTIONAL PARAMETER ===\nfunction log(message: string, level?: string): void {\n  console.log(`[${level ?? 'INFO'}] ${message}`);\n}\n\n// === DEFAULT PARAMETER ===\nfunction multiply(a: number, b: number = 2): number {\n  return a * b;\n}\n\n// === REST PARAMETERS ===\nfunction sum(...nums: number[]): number {\n  return nums.reduce((a, b) => a + b, 0);\n}\n\n// === FUNCTION OVERLOADS ===\nfunction getValue(key: 'name'): string;\nfunction getValue(key: 'age'): number;\nfunction getValue(key: 'name' | 'age'): string | number {\n  return key === 'name' ? 'Alice' : 30;\n}\n\n// === FUNCTION TYPE ===\ntype Callback = (data: string) => void;\nconst handler: Callback = (data) => console.log(data);\n\n// === ASYNC FUNCTION ===\nasync function fetchData(): Promise<{ data: string }> {\n  const res = await fetch('/api');\n  return res.json();\n}",
      "explanation": "Function signatures with all common patterns. Return type annotation after parameters."
    },
    {
      "title": "Interface vs Type Alias",
      "code": "// === INTERFACE (for objects, extendable) ===\ninterface User {\n  id: number;\n  name: string;\n  email?: string;           // Optional\n  readonly createdAt: Date; // Immutable\n}\n\n// Interface extension\ninterface Admin extends User {\n  role: 'admin' | 'superadmin';\n  permissions: string[];\n}\n\n// Interface merging (auto-merge)\ninterface User {\n  avatar?: string;  // Adds to original User\n}\n\n// === TYPE ALIAS (for unions, primitives, tuples) ===\ntype ID = string | number;               // Union\ntype Status = 'active' | 'inactive';     // Literal union\ntype Point = { x: number; y: number };   // Object\ntype Coord = [number, number];           // Tuple\ntype Callback = (msg: string) => void;   // Function\n\n// Type intersection\ntype Employee = User & { department: string };\n\n// === WHEN TO USE WHICH ===\n// Use INTERFACE for:\n//   - Object shapes\n//   - Class implementations\n//   - API contracts (extendable by consumers)\n\n// Use TYPE for:\n//   - Union types\n//   - Tuples\n//   - Function types\n//   - Complex computed types",
      "explanation": "Interfaces for object shapes and APIs, types for unions and complex types. Both work similarly for objects."
    },
    {
      "title": "Generic Patterns",
      "code": "// === GENERIC FUNCTION ===\nfunction identity<T>(value: T): T {\n  return value;\n}\nconst str = identity('hello');  // string\nconst num = identity(42);       // number\n\n// === GENERIC INTERFACE ===\ninterface Box<T> {\n  value: T;\n  getValue(): T;\n}\n\nconst stringBox: Box<string> = {\n  value: 'hello',\n  getValue() { return this.value; }\n};\n\n// === GENERIC CONSTRAINT ===\nfunction getLength<T extends { length: number }>(item: T): number {\n  return item.length;\n}\ngetLength('hello');      // OK\ngetLength([1, 2, 3]);    // OK\n// getLength(123);        // Error: number has no length\n\n// === GENERIC WITH KEYOF ===\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\nconst user = { name: 'Alice', age: 30 };\nconst name = getProperty(user, 'name');  // string\nconst age = getProperty(user, 'age');    // number\n\n// === MULTIPLE TYPE PARAMETERS ===\nfunction pair<T, U>(first: T, second: U): [T, U] {\n  return [first, second];\n}\nconst p = pair('hello', 42);  // [string, number]\n\n// === DEFAULT TYPE PARAMETER ===\ninterface Response<T = unknown> {\n  data: T;\n  status: number;\n}\nconst res: Response = { data: 'anything', status: 200 };",
      "explanation": "Generics create reusable, type-safe components. Use constraints to limit allowed types."
    },
    {
      "title": "Utility Types Cheat Sheet",
      "code": "interface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n}\n\n// === PARTIAL - All optional ===\ntype UpdateUser = Partial<User>;\n// { id?: number; name?: string; email?: string; password?: string }\n\n// === REQUIRED - All required ===\ntype CompleteUser = Required<Partial<User>>;\n\n// === READONLY - All immutable ===\ntype FrozenUser = Readonly<User>;\n\n// === PICK - Select properties ===\ntype UserPublic = Pick<User, 'id' | 'name'>;\n// { id: number; name: string }\n\n// === OMIT - Remove properties ===\ntype UserSafe = Omit<User, 'password'>;\n// { id: number; name: string; email: string }\n\n// === RECORD - Create object type ===\ntype UserRoles = Record<'admin' | 'user' | 'guest', boolean>;\n// { admin: boolean; user: boolean; guest: boolean }\n\n// === UNION MANIPULATION ===\ntype Status = 'active' | 'pending' | 'rejected' | 'approved';\n\ntype Completed = Extract<Status, 'approved' | 'rejected'>;\n// 'rejected' | 'approved'\n\ntype Pending = Exclude<Status, 'approved' | 'rejected'>;\n// 'active' | 'pending'\n\n// === FUNCTION UTILITIES ===\nfunction fetchUser(id: number): Promise<User> {\n  return fetch(`/api/user/${id}`).then(r => r.json());\n}\n\ntype FetchParams = Parameters<typeof fetchUser>;  // [number]\ntype FetchReturn = ReturnType<typeof fetchUser>;  // Promise<User>\ntype FetchData = Awaited<ReturnType<typeof fetchUser>>; // User\n\n// === NONNULLABLE ===\ntype MaybeString = string | null | undefined;\ntype DefiniteString = NonNullable<MaybeString>; // string",
      "explanation": "Utility types transform existing types without rewriting. Master these to avoid repetitive type definitions."
    },
    {
      "title": "Type Guards & Narrowing",
      "code": "// === TYPEOF GUARD ===\nfunction process(value: string | number): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase();  // value is string\n  }\n  return value.toFixed(2);  // value is number\n}\n\n// === INSTANCEOF GUARD ===\nclass Dog { bark() { return 'woof'; } }\nclass Cat { meow() { return 'meow'; } }\n\nfunction speak(pet: Dog | Cat): string {\n  if (pet instanceof Dog) {\n    return pet.bark();\n  }\n  return pet.meow();\n}\n\n// === IN OPERATOR GUARD ===\ninterface Bird { fly(): void; }\ninterface Fish { swim(): void; }\n\nfunction move(animal: Bird | Fish): void {\n  if ('fly' in animal) {\n    animal.fly();\n  } else {\n    animal.swim();\n  }\n}\n\n// === DISCRIMINATED UNION ===\ntype Result<T> = \n  | { success: true; data: T }\n  | { success: false; error: string };\n\nfunction handle<T>(result: Result<T>): T | never {\n  if (result.success) {\n    return result.data;  // TypeScript knows data exists\n  }\n  throw new Error(result.error);  // TypeScript knows error exists\n}\n\n// === CUSTOM TYPE GUARD ===\ninterface User { type: 'user'; name: string; }\ninterface Admin { type: 'admin'; name: string; permissions: string[]; }\n\nfunction isAdmin(person: User | Admin): person is Admin {\n  return person.type === 'admin';\n}\n\nfunction greet(person: User | Admin): void {\n  console.log(`Hello, ${person.name}`);\n  if (isAdmin(person)) {\n    console.log(`Permissions: ${person.permissions.join(', ')}`);\n  }\n}\n\n// === ASSERTION FUNCTION ===\nfunction assertDefined<T>(value: T | null | undefined): asserts value is T {\n  if (value === null || value === undefined) {\n    throw new Error('Value is not defined');\n  }\n}\n\nlet maybeUser: User | null = getUser();\nassertDefined(maybeUser);\nconsole.log(maybeUser.name);  // Safe - TypeScript knows it's defined",
      "explanation": "Type guards narrow union types at runtime. Custom guards with 'is' provide reusable narrowing."
    },
    {
      "title": "Classes & Access Modifiers",
      "code": "// === BASIC CLASS ===\nclass Person {\n  // Property declarations\n  public name: string;      // Accessible anywhere\n  private age: number;      // Only in this class\n  protected email: string;  // This class + subclasses\n  readonly id: number;      // Cannot reassign\n  \n  constructor(name: string, age: number, email: string) {\n    this.name = name;\n    this.age = age;\n    this.email = email;\n    this.id = Date.now();\n  }\n  \n  // Method\n  greet(): string {\n    return `Hello, I'm ${this.name}`;\n  }\n  \n  // Getter/Setter\n  get displayAge(): number {\n    return this.age;\n  }\n  \n  set displayAge(value: number) {\n    if (value > 0) this.age = value;\n  }\n}\n\n// === SHORTHAND CONSTRUCTOR ===\nclass User {\n  constructor(\n    public readonly id: number,\n    public name: string,\n    private password: string\n  ) {}\n  // Properties auto-created from constructor params!\n}\n\n// === IMPLEMENTING INTERFACE ===\ninterface Serializable {\n  serialize(): string;\n}\n\nclass Product implements Serializable {\n  constructor(public name: string, public price: number) {}\n  \n  serialize(): string {\n    return JSON.stringify({ name: this.name, price: this.price });\n  }\n}\n\n// === INHERITANCE ===\nclass Employee extends Person {\n  constructor(\n    name: string,\n    age: number,\n    email: string,\n    public department: string\n  ) {\n    super(name, age, email);  // Call parent constructor\n  }\n  \n  override greet(): string {\n    return `${super.greet()}, from ${this.department}`;\n  }\n}\n\n// === ABSTRACT CLASS ===\nabstract class Shape {\n  abstract area(): number;  // Must be implemented\n  \n  describe(): string {  // Can have implementation\n    return `Area: ${this.area()}`;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(public radius: number) {\n    super();\n  }\n  \n  area(): number {\n    return Math.PI * this.radius ** 2;\n  }\n}\n\n// === STATIC MEMBERS ===\nclass Counter {\n  static count = 0;\n  \n  static increment(): void {\n    Counter.count++;\n  }\n  \n  static getCount(): number {\n    return Counter.count;\n  }\n}",
      "explanation": "Classes with TypeScript features: access modifiers, shorthand constructors, abstract classes."
    },
    {
      "title": "Module System",
      "code": "// === NAMED EXPORTS (types.ts) ===\nexport interface User {\n  id: number;\n  name: string;\n}\n\nexport type Status = 'active' | 'inactive';\n\nexport const DEFAULT_STATUS: Status = 'active';\n\nexport function createUser(name: string): User {\n  return { id: Date.now(), name };\n}\n\n// === DEFAULT EXPORT (UserService.ts) ===\nexport default class UserService {\n  getUser(id: number): User | undefined {\n    // Implementation\n    return undefined;\n  }\n}\n\n// === NAMED IMPORTS (app.ts) ===\nimport { User, Status, createUser } from './types';\n\nconst user: User = createUser('Alice');\nconst status: Status = 'active';\n\n// === DEFAULT IMPORT ===\nimport UserService from './UserService';\nconst service = new UserService();\n\n// === MIXED IMPORTS ===\nimport UserService, { User, createUser } from './UserService';\n\n// === NAMESPACE IMPORT ===\nimport * as Types from './types';\nconst user: Types.User = { id: 1, name: 'Alice' };\n\n// === RENAMED IMPORT ===\nimport { User as IUser, createUser as makeUser } from './types';\nconst user: IUser = makeUser('Bob');\n\n// === TYPE-ONLY IMPORTS (TreeShaking friendly) ===\nimport type { User, Status } from './types';\nimport { createUser } from './types';\n\n// === RE-EXPORTING (index.ts barrel file) ===\nexport { User, Status, createUser } from './types';\nexport { default as UserService } from './UserService';\nexport type { User as IUser } from './types';  // Type-only re-export",
      "explanation": "ES modules in TypeScript. Use type-only imports for types to help bundlers optimize."
    },
    {
      "title": "Async Patterns",
      "code": "// === PROMISE TYPE ===\nfunction fetchUser(id: number): Promise<User> {\n  return fetch(`/api/users/${id}`).then(r => r.json());\n}\n\n// === ASYNC/AWAIT ===\nasync function getUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  const user = await response.json();\n  return user as User;\n}\n\n// === PARALLEL PROMISES ===\nasync function fetchAll(): Promise<[User[], Product[]]> {\n  const [users, products] = await Promise.all([\n    fetch('/api/users').then(r => r.json()) as Promise<User[]>,\n    fetch('/api/products').then(r => r.json()) as Promise<Product[]>\n  ]);\n  return [users, products];\n}\n\n// === ERROR HANDLING ===\ntype ApiResult<T> = \n  | { ok: true; data: T }\n  | { ok: false; error: string };\n\nasync function safeFetch<T>(url: string): Promise<ApiResult<T>> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      return { ok: false, error: `HTTP ${response.status}` };\n    }\n    const data = await response.json();\n    return { ok: true, data: data as T };\n  } catch (error) {\n    return { ok: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n// Usage\nconst result = await safeFetch<User>('/api/user/1');\nif (result.ok) {\n  console.log(result.data.name);  // TypeScript knows data exists\n} else {\n  console.error(result.error);    // TypeScript knows error exists\n}\n\n// === AWAITED UTILITY ===\ntype UserPromise = Promise<User>;\ntype ResolvedUser = Awaited<UserPromise>;  // User\n\n// === ASYNC ITERATOR ===\nasync function* generateUsers(): AsyncGenerator<User> {\n  for (let i = 0; i < 10; i++) {\n    yield await fetchUser(i);\n  }\n}\n\nfor await (const user of generateUsers()) {\n  console.log(user.name);\n}",
      "explanation": "Async patterns with proper typing. Use Result types for type-safe error handling."
    },
    {
      "title": "Configuration Quick Reference",
      "code": "// === STRICT TYPESCRIPT (recommended) ===\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,              // Enable all strict checks\n    \"target\": \"ES2022\",          // Modern JavaScript\n    \"module\": \"NodeNext\",        // Node.js modules\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,     // Better CJS/ESM interop\n    \"skipLibCheck\": true,        // Faster compilation\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,         // Generate .d.ts files\n    \"sourceMap\": true,           // Debug support\n    \"noEmit\": false\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n\n// === REACT/VITE PROJECT ===\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true\n  },\n  \"include\": [\"src\"]\n}\n\n// === NODE.JS BACKEND ===\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"types\": [\"node\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}",
      "explanation": "Common tsconfig.json configurations. Always enable 'strict' for new projects."
    }
  ]
}
