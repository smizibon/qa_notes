{
  "id": "examples-common-errors",
  "title": "Common Errors - Fix Reference",
  "description": "Quick reference for fixing the most common TypeScript errors with practical examples",
  "examples": [
    {
      "title": "TS2322 - Type Not Assignable",
      "code": "// PROBLEM: Type mismatch\nlet age: number = 'thirty';\n// Error: Type 'string' is not assignable to type 'number'\n\n// FIX 1: Use correct value type\nlet age: number = 30;\n\n// FIX 2: Change variable type to accept both\nlet age: number | string = 'thirty';\n\n// FIX 3: Convert the value\nlet age: number = Number('30');  // or parseInt('30')\n\n// PROBLEM: Missing properties\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst user: User = {\n  id: 1,\n  name: 'Alice'\n  // Error: Property 'email' is missing\n};\n\n// FIX 1: Add missing property\nconst user: User = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@example.com'\n};\n\n// FIX 2: Make property optional in interface\ninterface User {\n  id: number;\n  name: string;\n  email?: string;  // Now optional\n}\n\n// FIX 3: Use Partial for incomplete objects\nconst partialUser: Partial<User> = {\n  id: 1,\n  name: 'Alice'\n};",
      "explanation": "Type assignment errors occur when the value doesn't match the declared type. Either fix the value or the type."
    },
    {
      "title": "TS2532/TS2531 - Object Possibly Null or Undefined",
      "code": "// PROBLEM: Accessing property on potentially null value\nfunction getUser(id: string): User | null {\n  return database.get(id);\n}\n\nconst user = getUser('123');\nconsole.log(user.name);\n// Error: Object is possibly 'null'\n\n// FIX 1: Null check with if statement\nconst user = getUser('123');\nif (user) {\n  console.log(user.name);  // TypeScript knows user exists\n}\n\n// FIX 2: Optional chaining\nconst user = getUser('123');\nconsole.log(user?.name);  // Returns undefined if user is null\n\n// FIX 3: Nullish coalescing for default value\nconst user = getUser('123');\nconst name = user?.name ?? 'Unknown';\n\n// FIX 4: Early return / throw\nconst user = getUser('123');\nif (!user) {\n  throw new Error('User not found');\n}\nconsole.log(user.name);  // Safe - user exists here\n\n// FIX 5: Non-null assertion (use only when 100% certain!)\nconst user = getUser('123');\nconsole.log(user!.name);  // ! tells TS: trust me, it's not null\n\n// PROBLEM: Array methods that return undefined\nconst users: User[] = [];\nconst found = users.find(u => u.id === '123');\nconsole.log(found.name);\n// Error: Object is possibly 'undefined' (find can return undefined)\n\n// FIX: Handle the undefined case\nconst found = users.find(u => u.id === '123');\nif (found) {\n  console.log(found.name);\n} else {\n  console.log('User not found');\n}",
      "explanation": "TypeScript protects you from null/undefined errors. Always check before accessing properties."
    },
    {
      "title": "TS2339 - Property Does Not Exist",
      "code": "// PROBLEM: Property doesn't exist on type\nconst user = { name: 'Alice', email: 'alice@example.com' };\nconsole.log(user.age);\n// Error: Property 'age' does not exist on type '{ name: string; email: string }'\n\n// FIX 1: Add the property to the object\nconst user = { name: 'Alice', email: 'alice@example.com', age: 30 };\nconsole.log(user.age);\n\n// FIX 2: Define interface with the property\ninterface User {\n  name: string;\n  email: string;\n  age?: number;\n}\nconst user: User = { name: 'Alice', email: 'alice@example.com' };\nconsole.log(user.age);  // OK - might be undefined\n\n// PROBLEM: Accessing property on 'unknown' type\nconst data: unknown = JSON.parse('{\"name\": \"Alice\"}');\nconsole.log(data.name);\n// Error: Property 'name' does not exist on type 'unknown'\n\n// FIX 1: Type guard function\nfunction isUser(data: unknown): data is User {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'name' in data &&\n    typeof (data as any).name === 'string'\n  );\n}\n\nif (isUser(data)) {\n  console.log(data.name);  // Safe - TypeScript knows it's User\n}\n\n// FIX 2: Type assertion (use carefully!)\nconst user = data as User;\nconsole.log(user.name);\n\n// PROBLEM: Dynamic property access\nconst key = 'name';\nconst value = user[key];\n// Error: Element implicitly has 'any' type\n\n// FIX: Type the key\nconst key: keyof User = 'name';\nconst value = user[key];  // OK",
      "explanation": "Property errors occur when TypeScript doesn't know a property exists. Define types or use type guards."
    },
    {
      "title": "TS7006/TS7031 - Implicit Any",
      "code": "// PROBLEM: Parameter has implicit 'any' type\nfunction process(data) {\n// Error: Parameter 'data' implicitly has an 'any' type\n  return data.value;\n}\n\n// FIX 1: Add explicit parameter type\nfunction process(data: { value: string }): string {\n  return data.value;\n}\n\n// FIX 2: Use interface\ninterface InputData {\n  value: string;\n}\nfunction process(data: InputData): string {\n  return data.value;\n}\n\n// FIX 3: Use generic for flexibility\nfunction process<T extends { value: unknown }>(data: T): T['value'] {\n  return data.value;\n}\n\n// PROBLEM: Variable declared without type or value\nlet name;\n// Error: Variable 'name' implicitly has type 'any'\n\n// FIX 1: Initialize with value (type inferred)\nlet name = 'Alice';\n\n// FIX 2: Add explicit type\nlet name: string;\n\n// PROBLEM: Callback parameter has implicit any\nconst numbers = [1, 2, 3];\nnumbers.forEach(function(n) {\n// Error: Parameter 'n' implicitly has an 'any' type\n  console.log(n * 2);\n});\n\n// FIX 1: Use arrow function (type often inferred)\nconst numbers = [1, 2, 3];\nnumbers.forEach(n => console.log(n * 2));  // n is inferred as number\n\n// FIX 2: Explicit type annotation\nnumbers.forEach(function(n: number) {\n  console.log(n * 2);\n});",
      "explanation": "Enable 'noImplicitAny' in tsconfig.json to catch these. Always type function parameters."
    },
    {
      "title": "TS2345 - Argument Type Mismatch",
      "code": "// PROBLEM: Wrong argument type\nfunction greet(name: string): void {\n  console.log(`Hello, ${name}`);\n}\n\ngreet(123);\n// Error: Argument of type 'number' is not assignable to parameter of type 'string'\n\n// FIX 1: Pass correct type\ngreet('Alice');\n\n// FIX 2: Convert the value\ngreet(String(123));\ngreet((123).toString());\n\n// FIX 3: Change function to accept both types\nfunction greet(name: string | number): void {\n  console.log(`Hello, ${name}`);\n}\ngreet(123);  // OK now\n\n// PROBLEM: Object missing properties in function call\ninterface Config {\n  host: string;\n  port: number;\n  ssl: boolean;\n}\n\nfunction connect(config: Config): void {\n  console.log(`Connecting to ${config.host}:${config.port}`);\n}\n\nconnect({ host: 'localhost', port: 3000 });\n// Error: Property 'ssl' is missing\n\n// FIX 1: Provide all required properties\nconnect({ host: 'localhost', port: 3000, ssl: true });\n\n// FIX 2: Make properties optional\ninterface Config {\n  host: string;\n  port: number;\n  ssl?: boolean;  // Now optional\n}\n\n// FIX 3: Use Partial<Config>\nfunction connect(config: Partial<Config>): void {\n  const { host = 'localhost', port = 3000, ssl = false } = config;\n  console.log(`Connecting to ${host}:${port}`);\n}",
      "explanation": "Argument errors occur when function call doesn't match parameter types. Fix the argument or the function signature."
    },
    {
      "title": "TS1064/TS2322 - Async/Promise Errors",
      "code": "// PROBLEM: Accessing Promise instead of resolved value\nasync function fetchUser(): Promise<{ name: string }> {\n  return { name: 'Alice' };\n}\n\nconst user = fetchUser();\nconsole.log(user.name);\n// Error: Property 'name' does not exist on type 'Promise<{ name: string }>'\n\n// FIX 1: Use await\nasync function main() {\n  const user = await fetchUser();\n  console.log(user.name);  // OK\n}\n\n// FIX 2: Use .then()\nfetchUser().then(user => {\n  console.log(user.name);  // OK\n});\n\n// PROBLEM: Function returns value but type says Promise\nfunction getUser(): Promise<User> {\n  return { name: 'Alice', id: 1 };\n// Error: Type '{ name: string; id: number }' is not assignable to type 'Promise<User>'\n}\n\n// FIX 1: Make function async\nasync function getUser(): Promise<User> {\n  return { name: 'Alice', id: 1 };  // Automatically wrapped in Promise\n}\n\n// FIX 2: Return Promise.resolve\nfunction getUser(): Promise<User> {\n  return Promise.resolve({ name: 'Alice', id: 1 });\n}\n\n// FIX 3: Change return type if not async\nfunction getUser(): User {\n  return { name: 'Alice', id: 1 };\n}\n\n// PROBLEM: Using await outside async function\nconst data = await fetchData();\n// Error: 'await' expressions are only allowed within async functions\n\n// FIX: Wrap in async function or IIFE\nasync function main() {\n  const data = await fetchData();\n}\nmain();\n\n// Or IIFE (Immediately Invoked Function Expression)\n(async () => {\n  const data = await fetchData();\n})();",
      "explanation": "Async functions always return Promises. Use await or .then() to get the resolved value."
    },
    {
      "title": "TS2304 - Cannot Find Name",
      "code": "// PROBLEM: Variable not declared\nconsole.log(userName);\n// Error: Cannot find name 'userName'\n\n// FIX 1: Declare the variable\nconst userName = 'Alice';\nconsole.log(userName);\n\n// FIX 2: Import from another file\nimport { userName } from './user';\nconsole.log(userName);\n\n// FIX 3: Check spelling\nconst username = 'Alice';  // Was it lowercase?\nconsole.log(username);\n\n// PROBLEM: Missing global type definitions\nconsole.log(process.env.API_KEY);\n// Error: Cannot find name 'process'\n\n// FIX 1: Install Node.js types\n// npm install --save-dev @types/node\n\n// FIX 2: Declare the global\ndeclare const process: {\n  env: Record<string, string | undefined>;\n};\n\n// PROBLEM: Missing built-in types\nconst map = new Map<string, number>();\n// Error: Cannot find name 'Map' (if using old target)\n\n// FIX: Update tsconfig.json lib\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2015\",\n    \"lib\": [\"ES2015\", \"DOM\"]\n  }\n}\n\n// PROBLEM: Third-party library without types\nimport express from 'express';\n// Error: Cannot find module 'express' or its corresponding type declarations\n\n// FIX: Install type definitions\n// npm install --save-dev @types/express\n\n// Or declare module if types don't exist\ndeclare module 'some-untyped-library';",
      "explanation": "'Cannot find name' usually means missing declaration, import, or type definitions."
    },
    {
      "title": "TS7053 - Index Signature Errors",
      "code": "// PROBLEM: Dynamic property access\nconst user = { name: 'Alice', age: 30 };\nconst key = 'name';\nconst value = user[key];\n// Error: Element implicitly has an 'any' type because expression\n// of type 'string' can't be used to index type '{ name: string; age: number }'\n\n// FIX 1: Type the key as keyof\nconst key: keyof typeof user = 'name';\nconst value = user[key];  // OK - value is string | number\n\n// FIX 2: Use type assertion\nconst key = 'name' as keyof typeof user;\nconst value = user[key];\n\n// FIX 3: Add index signature to interface\ninterface User {\n  [key: string]: string | number;\n  name: string;\n  age: number;\n}\nconst user: User = { name: 'Alice', age: 30 };\nconst value = user['name'];  // OK\n\n// PROBLEM: Iterating with for...in\nfor (const key in user) {\n  console.log(user[key]);\n  // Error: Element implicitly has 'any' type\n}\n\n// FIX: Assert key type in loop\nfor (const key in user) {\n  const k = key as keyof typeof user;\n  console.log(user[k]);\n}\n\n// Or use Object.entries\nfor (const [key, value] of Object.entries(user)) {\n  console.log(key, value);  // Both properly typed\n}\n\n// PROBLEM: Building object dynamically\nconst result: { [key: string]: number } = {};\nconst keys = ['a', 'b', 'c'];\nkeys.forEach((key, i) => {\n  result[key] = i;  // OK with index signature\n});",
      "explanation": "TypeScript needs to know that dynamic keys are valid. Use keyof, index signatures, or Object.entries."
    },
    {
      "title": "TS2451 - Cannot Redeclare Variable",
      "code": "// PROBLEM: Duplicate variable declaration\nconst name = 'Alice';\nconst name = 'Bob';\n// Error: Cannot redeclare block-scoped variable 'name'\n\n// FIX 1: Use different names\nconst firstName = 'Alice';\nconst lastName = 'Bob';\n\n// FIX 2: Use let and reassign\nlet name = 'Alice';\nname = 'Bob';  // Reassignment, not redeclaration\n\n// FIX 3: Use different scopes\nif (true) {\n  const name = 'Alice';\n}\nif (true) {\n  const name = 'Bob';  // Different scope, OK\n}\n\n// PROBLEM: Script files share global scope\n// file1.ts\nconst API_URL = 'https://api.example.com';\n\n// file2.ts\nconst API_URL = 'https://api2.example.com';\n// Error: Cannot redeclare block-scoped variable 'API_URL'\n\n// FIX 1: Add export to make files modules\n// file1.ts\nexport const API_URL = 'https://api.example.com';\n\n// file2.ts\nexport const API_URL = 'https://api2.example.com';\n// Now each file has its own scope\n\n// FIX 2: Add empty export to make it a module\n// file.ts\nconst myVar = 'value';\nexport {};  // Makes this file a module\n\n// PROBLEM: Variable shadows import\nimport { User } from './types';\nconst User = { name: 'Alice' };\n// Error: 'User' is a type and cannot be used as a value\n\n// FIX: Use different name\nimport { User } from './types';\nconst userData = { name: 'Alice' };",
      "explanation": "Each variable must be declared once per scope. Use exports to create module scope."
    },
    {
      "title": "TS2571 - Object is of Type 'unknown'",
      "code": "// PROBLEM: Can't use unknown type directly\nasync function fetchData(): Promise<unknown> {\n  const res = await fetch('/api/data');\n  return res.json();\n}\n\nconst data = await fetchData();\nconsole.log(data.name);\n// Error: Object is of type 'unknown'\n\n// FIX 1: Type guard function\ninterface User {\n  name: string;\n  email: string;\n}\n\nfunction isUser(value: unknown): value is User {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'name' in value &&\n    'email' in value &&\n    typeof (value as User).name === 'string' &&\n    typeof (value as User).email === 'string'\n  );\n}\n\nconst data = await fetchData();\nif (isUser(data)) {\n  console.log(data.name);  // Safe!\n}\n\n// FIX 2: Type assertion (use carefully)\nconst data = await fetchData() as User;\nconsole.log(data.name);\n\n// FIX 3: Narrow with typeof for primitives\nfunction process(value: unknown): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase();  // OK - value is string\n  }\n  if (typeof value === 'number') {\n    return value.toFixed(2);  // OK - value is number\n  }\n  return String(value);\n}\n\n// FIX 4: Use a validation library like Zod\nimport { z } from 'zod';\n\nconst UserSchema = z.object({\n  name: z.string(),\n  email: z.string().email()\n});\n\nconst data = await fetchData();\nconst user = UserSchema.parse(data);  // Throws if invalid\nconsole.log(user.name);  // Fully typed!",
      "explanation": "'unknown' is safer than 'any' but requires type narrowing before use. Validate external data!"
    }
  ]
}
