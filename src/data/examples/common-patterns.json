{
  "id": "examples-common-patterns",
  "title": "Common Patterns - Practical Examples",
  "description": "Real-world examples of common TypeScript patterns for maintainable, type-safe applications",
  "examples": [
    {
      "title": "Result Type for Error Handling",
      "code": "// Result type definition\ntype Result<T, E = Error> =\n  | { ok: true; value: T }\n  | { ok: false; error: E };\n\n// Helper functions\nfunction Ok<T>(value: T): Result<T, never> {\n  return { ok: true, value };\n}\n\nfunction Err<E>(error: E): Result<never, E> {\n  return { ok: false, error };\n}\n\n// Utility functions\nfunction map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> {\n  return result.ok ? Ok(fn(result.value)) : result;\n}\n\nfunction flatMap<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> {\n  return result.ok ? fn(result.value) : result;\n}\n\nfunction unwrap<T, E>(result: Result<T, E>): T {\n  if (result.ok) return result.value;\n  throw result.error;\n}\n\nfunction unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {\n  return result.ok ? result.value : defaultValue;\n}\n\n// Real-world usage\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ntype ValidationError = { field: string; message: string };\n\nfunction validateEmail(email: string): Result<string, ValidationError> {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    return Err({ field: 'email', message: 'Invalid email format' });\n  }\n  return Ok(email);\n}\n\nfunction validateName(name: string): Result<string, ValidationError> {\n  if (name.length < 2) {\n    return Err({ field: 'name', message: 'Name must be at least 2 characters' });\n  }\n  return Ok(name);\n}\n\nfunction createUser(\n  name: string,\n  email: string\n): Result<User, ValidationError> {\n  const nameResult = validateName(name);\n  if (!nameResult.ok) return nameResult;\n  \n  const emailResult = validateEmail(email);\n  if (!emailResult.ok) return emailResult;\n  \n  return Ok({\n    id: crypto.randomUUID(),\n    name: nameResult.value,\n    email: emailResult.value\n  });\n}\n\n// Usage\nconst result = createUser('Alice', 'alice@example.com');\n\nif (result.ok) {\n  console.log(`Created user: ${result.value.name}`);\n} else {\n  console.error(`Validation error in ${result.error.field}: ${result.error.message}`);\n}",
      "explanation": "Result type makes error handling explicit in the type system. No surprises from uncaught exceptions."
    },
    {
      "title": "Branded Types for Domain Modeling",
      "code": "// Brand utility type\ntype Brand<K, T> = K & { readonly __brand: T };\n\n// Define branded types for different IDs\ntype UserId = Brand<string, 'UserId'>;\ntype OrderId = Brand<string, 'OrderId'>;\ntype ProductId = Brand<string, 'ProductId'>;\n\n// Define branded types for validated values\ntype Email = Brand<string, 'Email'>;\ntype PositiveNumber = Brand<number, 'PositiveNumber'>;\ntype NonEmptyString = Brand<string, 'NonEmptyString'>;\n\n// Factory functions with validation\nfunction UserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction OrderId(id: string): OrderId {\n  return id as OrderId;\n}\n\nfunction ProductId(id: string): ProductId {\n  return id as ProductId;\n}\n\nfunction Email(email: string): Email | null {\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return regex.test(email) ? (email as Email) : null;\n}\n\nfunction PositiveNumber(n: number): PositiveNumber | null {\n  return n > 0 ? (n as PositiveNumber) : null;\n}\n\nfunction NonEmptyString(s: string): NonEmptyString | null {\n  return s.length > 0 ? (s as NonEmptyString) : null;\n}\n\n// Domain models using branded types\ninterface Order {\n  id: OrderId;\n  userId: UserId;\n  items: Array<{ productId: ProductId; quantity: PositiveNumber }>;\n  total: PositiveNumber;\n}\n\ninterface User {\n  id: UserId;\n  name: NonEmptyString;\n  email: Email;\n}\n\n// Functions that require specific branded types\nfunction getOrder(id: OrderId): Order | null {\n  // Implementation\n  return null;\n}\n\nfunction getUser(id: UserId): User | null {\n  // Implementation\n  return null;\n}\n\nfunction getUserOrders(userId: UserId): Order[] {\n  // Implementation\n  return [];\n}\n\n// Usage - type-safe, can't mix up IDs!\nconst userId = UserId('user-123');\nconst orderId = OrderId('order-456');\nconst productId = ProductId('prod-789');\n\ngetUser(userId);      // ✓ OK\ngetOrder(orderId);    // ✓ OK\n\n// These would be type errors:\n// getUser(orderId);  // ✗ OrderId not assignable to UserId\n// getOrder(userId);  // ✗ UserId not assignable to OrderId\n// getUser('123');    // ✗ string not assignable to UserId",
      "explanation": "Branded types prevent mixing up IDs and ensure validated values are used throughout the codebase."
    },
    {
      "title": "State Machine for Async Operations",
      "code": "// State machine types\ntype AsyncState<T, E = Error> =\n  | { status: 'idle' }\n  | { status: 'pending'; startedAt: Date }\n  | { status: 'fulfilled'; data: T; completedAt: Date }\n  | { status: 'rejected'; error: E; failedAt: Date };\n\n// State machine class\nclass AsyncStateMachine<T, E = Error> {\n  private state: AsyncState<T, E> = { status: 'idle' };\n  private listeners: Array<(state: AsyncState<T, E>) => void> = [];\n\n  getState(): AsyncState<T, E> {\n    return this.state;\n  }\n\n  subscribe(listener: (state: AsyncState<T, E>) => void): () => void {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  private setState(newState: AsyncState<T, E>): void {\n    this.state = newState;\n    this.listeners.forEach(l => l(this.state));\n  }\n\n  async execute(operation: () => Promise<T>): Promise<T> {\n    if (this.state.status === 'pending') {\n      throw new Error('Operation already in progress');\n    }\n\n    this.setState({ status: 'pending', startedAt: new Date() });\n\n    try {\n      const data = await operation();\n      this.setState({ status: 'fulfilled', data, completedAt: new Date() });\n      return data;\n    } catch (error) {\n      const e = error instanceof Error ? error : new Error(String(error));\n      this.setState({ status: 'rejected', error: e as E, failedAt: new Date() });\n      throw error;\n    }\n  }\n\n  reset(): void {\n    this.setState({ status: 'idle' });\n  }\n}\n\n// React-like hook usage\nfunction createUseAsync<T, E = Error>() {\n  return function useAsync(operation: () => Promise<T>) {\n    const machine = new AsyncStateMachine<T, E>();\n    \n    return {\n      state: machine.getState(),\n      execute: () => machine.execute(operation),\n      reset: () => machine.reset(),\n      subscribe: machine.subscribe.bind(machine)\n    };\n  };\n}\n\n// Type-safe state handling\nfunction renderState<T>(state: AsyncState<T>): string {\n  switch (state.status) {\n    case 'idle':\n      return 'Click to load';\n    case 'pending':\n      return `Loading since ${state.startedAt.toLocaleTimeString()}`;\n    case 'fulfilled':\n      return `Loaded at ${state.completedAt.toLocaleTimeString()}`;\n    case 'rejected':\n      return `Error: ${state.error.message}`;\n  }\n}\n\n// Usage\nconst userLoader = new AsyncStateMachine<{ name: string }>();\n\nuserLoader.subscribe((state) => {\n  console.log(renderState(state));\n});\n\nawait userLoader.execute(async () => {\n  const response = await fetch('/api/user');\n  return response.json();\n});\n\nconst state = userLoader.getState();\nif (state.status === 'fulfilled') {\n  console.log(`Hello, ${state.data.name}!`);\n}",
      "explanation": "State machine pattern with discriminated unions ensures exhaustive handling and prevents impossible states."
    },
    {
      "title": "Repository Pattern with Generics",
      "code": "// Base entity interface\ninterface Entity {\n  id: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Generic repository interface\ninterface Repository<T extends Entity> {\n  findById(id: string): Promise<T | null>;\n  findAll(options?: { limit?: number; offset?: number }): Promise<T[]>;\n  findBy(query: Partial<T>): Promise<T[]>;\n  create(data: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T>;\n  update(id: string, data: Partial<Omit<T, 'id' | 'createdAt' | 'updatedAt'>>): Promise<T>;\n  delete(id: string): Promise<boolean>;\n  count(): Promise<number>;\n}\n\n// Domain entities\ninterface User extends Entity {\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\ninterface Product extends Entity {\n  name: string;\n  price: number;\n  inStock: boolean;\n}\n\n// In-memory implementation for testing\nclass InMemoryRepository<T extends Entity> implements Repository<T> {\n  protected items: T[] = [];\n\n  async findById(id: string): Promise<T | null> {\n    return this.items.find(item => item.id === id) ?? null;\n  }\n\n  async findAll(options?: { limit?: number; offset?: number }): Promise<T[]> {\n    const { limit = 100, offset = 0 } = options ?? {};\n    return this.items.slice(offset, offset + limit);\n  }\n\n  async findBy(query: Partial<T>): Promise<T[]> {\n    return this.items.filter(item => {\n      return Object.entries(query).every(([key, value]) => \n        item[key as keyof T] === value\n      );\n    });\n  }\n\n  async create(data: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T> {\n    const now = new Date();\n    const item = {\n      ...data,\n      id: crypto.randomUUID(),\n      createdAt: now,\n      updatedAt: now\n    } as T;\n    this.items.push(item);\n    return item;\n  }\n\n  async update(id: string, data: Partial<Omit<T, 'id' | 'createdAt' | 'updatedAt'>>): Promise<T> {\n    const item = await this.findById(id);\n    if (!item) throw new Error('Item not found');\n    Object.assign(item, { ...data, updatedAt: new Date() });\n    return item;\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const index = this.items.findIndex(item => item.id === id);\n    if (index === -1) return false;\n    this.items.splice(index, 1);\n    return true;\n  }\n\n  async count(): Promise<number> {\n    return this.items.length;\n  }\n}\n\n// API implementation\nclass ApiRepository<T extends Entity> implements Repository<T> {\n  constructor(private baseUrl: string) {}\n\n  async findById(id: string): Promise<T | null> {\n    const res = await fetch(`${this.baseUrl}/${id}`);\n    return res.ok ? res.json() : null;\n  }\n\n  async findAll(options?: { limit?: number; offset?: number }): Promise<T[]> {\n    const params = new URLSearchParams();\n    if (options?.limit) params.set('limit', String(options.limit));\n    if (options?.offset) params.set('offset', String(options.offset));\n    const res = await fetch(`${this.baseUrl}?${params}`);\n    return res.json();\n  }\n\n  async findBy(query: Partial<T>): Promise<T[]> {\n    const params = new URLSearchParams(query as Record<string, string>);\n    const res = await fetch(`${this.baseUrl}?${params}`);\n    return res.json();\n  }\n\n  async create(data: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T> {\n    const res = await fetch(this.baseUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n    return res.json();\n  }\n\n  async update(id: string, data: Partial<Omit<T, 'id' | 'createdAt' | 'updatedAt'>>): Promise<T> {\n    const res = await fetch(`${this.baseUrl}/${id}`, {\n      method: 'PATCH',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n    return res.json();\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const res = await fetch(`${this.baseUrl}/${id}`, { method: 'DELETE' });\n    return res.ok;\n  }\n\n  async count(): Promise<number> {\n    const res = await fetch(`${this.baseUrl}/count`);\n    return res.json();\n  }\n}\n\n// Usage\nconst usersRepo: Repository<User> = process.env.NODE_ENV === 'test'\n  ? new InMemoryRepository<User>()\n  : new ApiRepository<User>('/api/users');\n\nconst user = await usersRepo.create({\n  name: 'Alice',\n  email: 'alice@example.com',\n  role: 'user'\n});\n\nconst admins = await usersRepo.findBy({ role: 'admin' });",
      "explanation": "Repository pattern abstracts data access, making it easy to swap implementations and test."
    },
    {
      "title": "Type-Safe Event System",
      "code": "// Event definitions\ninterface EventMap {\n  'user:login': { userId: string; timestamp: Date };\n  'user:logout': { userId: string };\n  'cart:add': { productId: string; quantity: number };\n  'cart:remove': { productId: string };\n  'checkout:complete': { orderId: string; total: number };\n}\n\ntype EventName = keyof EventMap;\n\n// Type-safe event emitter\nclass TypedEventEmitter<Events extends Record<string, unknown>> {\n  private handlers = new Map<keyof Events, Set<Function>>();\n\n  on<E extends keyof Events>(\n    event: E,\n    handler: (payload: Events[E]) => void\n  ): () => void {\n    if (!this.handlers.has(event)) {\n      this.handlers.set(event, new Set());\n    }\n    this.handlers.get(event)!.add(handler);\n\n    // Return unsubscribe function\n    return () => {\n      this.handlers.get(event)?.delete(handler);\n    };\n  }\n\n  once<E extends keyof Events>(\n    event: E,\n    handler: (payload: Events[E]) => void\n  ): () => void {\n    const wrapper = (payload: Events[E]) => {\n      handler(payload);\n      unsubscribe();\n    };\n    const unsubscribe = this.on(event, wrapper);\n    return unsubscribe;\n  }\n\n  emit<E extends keyof Events>(event: E, payload: Events[E]): void {\n    this.handlers.get(event)?.forEach(handler => handler(payload));\n  }\n\n  off<E extends keyof Events>(event: E): void {\n    this.handlers.delete(event);\n  }\n\n  clear(): void {\n    this.handlers.clear();\n  }\n}\n\n// Create app-wide event bus\nconst eventBus = new TypedEventEmitter<EventMap>();\n\n// Analytics module subscribes to events\nconst unsubscribeLogin = eventBus.on('user:login', ({ userId, timestamp }) => {\n  console.log(`Analytics: User ${userId} logged in at ${timestamp}`);\n});\n\neventBus.on('checkout:complete', ({ orderId, total }) => {\n  console.log(`Analytics: Order ${orderId} completed for $${total}`);\n});\n\n// Auth module emits events\nfunction login(userId: string): void {\n  // ... login logic\n  eventBus.emit('user:login', { userId, timestamp: new Date() });\n}\n\n// Cart module emits events\nfunction addToCart(productId: string, quantity: number): void {\n  // ... add to cart logic\n  eventBus.emit('cart:add', { productId, quantity });\n}\n\n// Cleanup when needed\nunsubscribeLogin();\n\n// Type errors:\n// eventBus.emit('user:login', { wrong: 'data' });  // ✗ Wrong payload\n// eventBus.emit('unknown', {});  // ✗ Unknown event",
      "explanation": "Type-safe event system with proper payload types and automatic cleanup with unsubscribe functions."
    },
    {
      "title": "Dependency Injection Container",
      "code": "// Token for type-safe DI\ntype Token<T> = symbol & { __type: T };\n\nfunction createToken<T>(name: string): Token<T> {\n  return Symbol(name) as Token<T>;\n}\n\n// DI Container\nclass Container {\n  private services = new Map<symbol, unknown>();\n  private factories = new Map<symbol, () => unknown>();\n\n  register<T>(token: Token<T>, instance: T): void {\n    this.services.set(token, instance);\n  }\n\n  registerFactory<T>(token: Token<T>, factory: () => T): void {\n    this.factories.set(token, factory);\n  }\n\n  resolve<T>(token: Token<T>): T {\n    if (this.services.has(token)) {\n      return this.services.get(token) as T;\n    }\n    \n    const factory = this.factories.get(token);\n    if (factory) {\n      const instance = factory() as T;\n      this.services.set(token, instance); // Cache singleton\n      return instance;\n    }\n    \n    throw new Error(`Service not registered: ${token.toString()}`);\n  }\n}\n\n// Service interfaces\ninterface Logger {\n  log(message: string): void;\n  error(message: string): void;\n}\n\ninterface ConfigService {\n  get<T>(key: string): T | undefined;\n}\n\ninterface UserRepository {\n  findById(id: string): Promise<{ id: string; name: string } | null>;\n}\n\n// Create tokens\nconst LoggerToken = createToken<Logger>('Logger');\nconst ConfigToken = createToken<ConfigService>('Config');\nconst UserRepoToken = createToken<UserRepository>('UserRepo');\n\n// Implementations\nclass ConsoleLogger implements Logger {\n  log(message: string) { console.log(`[INFO] ${message}`); }\n  error(message: string) { console.error(`[ERROR] ${message}`); }\n}\n\nclass EnvConfigService implements ConfigService {\n  get<T>(key: string): T | undefined {\n    return process.env[key] as T | undefined;\n  }\n}\n\nclass ApiUserRepository implements UserRepository {\n  constructor(private logger: Logger, private baseUrl: string) {}\n  \n  async findById(id: string) {\n    this.logger.log(`Fetching user ${id}`);\n    const res = await fetch(`${this.baseUrl}/users/${id}`);\n    return res.ok ? res.json() : null;\n  }\n}\n\n// Setup container\nconst container = new Container();\n\ncontainer.register(LoggerToken, new ConsoleLogger());\ncontainer.register(ConfigToken, new EnvConfigService());\n\ncontainer.registerFactory(UserRepoToken, () => {\n  const logger = container.resolve(LoggerToken);\n  const config = container.resolve(ConfigToken);\n  const baseUrl = config.get<string>('API_URL') ?? 'http://localhost:3000';\n  return new ApiUserRepository(logger, baseUrl);\n});\n\n// Usage\nconst userRepo = container.resolve(UserRepoToken);\nconst user = await userRepo.findById('123');",
      "explanation": "Type-safe dependency injection container with tokens ensuring correct types are resolved."
    },
    {
      "title": "Fluent Builder with Required Fields",
      "code": "// Type to track required fields that have been set\ntype RequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K;\n}[keyof T];\n\n// Builder that tracks which required fields are set\nclass FluentBuilder<T, Set extends keyof T = never> {\n  private data: Partial<T> = {};\n\n  set<K extends keyof T>(key: K, value: T[K]): FluentBuilder<T, Set | K> {\n    this.data[key] = value;\n    return this as unknown as FluentBuilder<T, Set | K>;\n  }\n\n  // Build is only available when all required keys are set\n  build(this: FluentBuilder<T, RequiredKeys<T>>): T {\n    return this.data as T;\n  }\n}\n\n// Usage with strict required fields\ninterface UserConfig {\n  name: string;         // Required\n  email: string;        // Required\n  age?: number;         // Optional\n  role?: 'admin' | 'user'; // Optional\n}\n\nfunction createUser(): FluentBuilder<UserConfig> {\n  return new FluentBuilder<UserConfig>();\n}\n\n// Must set name and email before build() is available\nconst user = createUser()\n  .set('name', 'Alice')\n  .set('email', 'alice@example.com')\n  .set('age', 30)  // Optional\n  .build();  // ✓ OK - all required fields set\n\n// This would fail:\n// createUser()\n//   .set('name', 'Alice')\n//   .build();  // ✗ Error - email not set\n\n// More complex example\ninterface HttpRequest {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  url: string;\n  headers?: Record<string, string>;\n  body?: unknown;\n  timeout?: number;\n}\n\nfunction request(): FluentBuilder<HttpRequest> {\n  return new FluentBuilder<HttpRequest>();\n}\n\nconst req = request()\n  .set('method', 'POST')\n  .set('url', '/api/users')\n  .set('body', { name: 'Alice' })\n  .set('headers', { 'Content-Type': 'application/json' })\n  .build();\n\nconsole.log(req);",
      "explanation": "Fluent builder that uses TypeScript's type system to ensure all required fields are set before building."
    },
    {
      "title": "Const Assertions for Configuration",
      "code": "// Configuration with const assertion\nconst config = {\n  api: {\n    baseUrl: 'https://api.example.com',\n    timeout: 5000,\n    retries: 3\n  },\n  features: {\n    darkMode: true,\n    betaFeatures: false,\n    newDashboard: true\n  },\n  routes: {\n    home: '/',\n    about: '/about',\n    users: '/users',\n    settings: '/settings'\n  }\n} as const;\n\n// Extract types from config\ntype Config = typeof config;\ntype ApiConfig = Config['api'];\ntype Features = Config['features'];\ntype Routes = Config['routes'];\n\n// Type for route paths\ntype RoutePath = Routes[keyof Routes];\n// = '/' | '/about' | '/users' | '/settings'\n\n// Type for feature names\ntype FeatureName = keyof Features;\n// = 'darkMode' | 'betaFeatures' | 'newDashboard'\n\n// Type-safe route navigation\nfunction navigate(path: RoutePath): void {\n  window.location.href = path;\n}\n\nnavigate(config.routes.home);      // ✓ OK\nnavigate(config.routes.users);     // ✓ OK\n// navigate('/invalid');            // ✗ Error: not a valid route\n\n// Type-safe feature check\nfunction isEnabled(feature: FeatureName): boolean {\n  return config.features[feature];\n}\n\nisEnabled('darkMode');    // ✓ OK\nisEnabled('betaFeatures'); // ✓ OK\n// isEnabled('unknown');   // ✗ Error: not a valid feature\n\n// Derive enums from config\nconst RouteNames = Object.keys(config.routes) as (keyof Routes)[];\n// ['home', 'about', 'users', 'settings']\n\n// Create a type-safe route builder\nfunction buildUrl<K extends keyof Routes>(\n  route: K,\n  params?: Record<string, string>\n): string {\n  let url = config.routes[route] as string;\n  if (params) {\n    Object.entries(params).forEach(([key, value]) => {\n      url = url.replace(`:${key}`, value);\n    });\n  }\n  return `${config.api.baseUrl}${url}`;\n}\n\nconsole.log(buildUrl('users'));  // 'https://api.example.com/users'",
      "explanation": "Const assertions preserve literal types, enabling type-safe access to configuration values."
    }
  ]
}
