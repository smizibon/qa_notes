{
  "id": "core-components",
  "title": "Core Components",
  "explanation": "Master the essential building blocks of effective prompts: standard prompts, system messages, and how to use them to steer AI behavior. These components form the foundation of advanced prompt engineering.",
  "codeBlocks": [
    {
      "title": "Standard Prompts: The Starting Point",
      "code": "// Standard prompts are your direct instructions to the AI\n// They consist of several key components:\n\n// 1. TASK - What you want done\nPrompt: \"Generate test cases\"\n\n// 2. CONTEXT - Background information\nPrompt: \"For a payment processing API that handles credit cards\"\n\n// 3. CONSTRAINTS - Limitations and requirements\nPrompt: \"Must cover security, validation, and edge cases\"\n\n// 4. FORMAT - How you want the output\nPrompt: \"Format as markdown table with columns: ID, Scenario, Steps, Expected Result\"\n\n// COMPLETE STANDARD PROMPT:\nPrompt: `Generate test cases for a payment processing API \nthat handles credit cards. Must cover security, validation, \nand edge cases. Format as markdown table with columns: \nID, Scenario, Steps, Expected Result.`\n\n// COMPONENTS BREAKDOWN:\n// Task: \"Generate test cases\"\n// Context: \"payment processing API that handles credit cards\"\n// Constraints: \"security, validation, and edge cases\"\n// Format: \"markdown table with columns...\"\n\n// ✅ GOOD Standard Prompt Structure:\n[Role] + [Task] + [Context] + [Constraints] + [Format] + [Examples]\n\n// Example:\n\"As a senior QA engineer, write 10 test scenarios for a \nuser authentication API (OAuth 2.0). Include positive flows, \nerror cases, and security tests. Output as numbered list \nwith: Scenario name, Test steps, Expected result.\"\n\n// ❌ POOR Standard Prompt:\n\"Write some tests\"\n// Missing: role, context, constraints, format"
    },
    {
      "title": "System Messages: The Hidden Guide",
      "code": "// System messages set the AI's behavior and personality\n// They run \"behind the scenes\" and persist across the conversation\n\n// WHAT ARE SYSTEM MESSAGES?\n// System messages define:\n// 1. WHO the AI should act as\n// 2. HOW it should respond\n// 3. WHAT rules it must follow\n// 4. WHAT it should emphasize or avoid\n\n// EXAMPLE SYSTEM MESSAGE:\nSystemMessage: `You are an expert QA automation engineer \nspecializing in API testing. You:\n- Provide practical, implementable solutions\n- Always consider edge cases and error scenarios\n- Write clean, maintainable test code\n- Follow industry best practices (AAA pattern, meaningful names)\n- Prioritize security and data validation\n- Explain your reasoning\n\nWhen writing test cases:\n- Use Given-When-Then format\n- Include setup and teardown considerations\n- Mention potential flaky test risks\n- Suggest assertion strategies\n\nNever:\n- Provide untested or theoretical solutions\n- Skip error handling\n- Make assumptions without stating them`\n\n// Now user prompts get filtered through this context!\n\nUserPrompt: \"How do I test this endpoint?\"\n// AI responds AS the expert QA engineer defined above\n\n// WITHOUT system message:\n// Generic advice, may miss testing specifics\n\n// WITH system message:\n// Response includes edge cases, follows AAA pattern,\n// mentions flaky test risks - all from system message!\n\n// SYSTEM MESSAGE STRUCTURE:\n// 1. Identity definition\n// 2. Behavioral guidelines\n// 3. Output requirements\n// 4. Explicit constraints\n// 5. Things to avoid"
    },
    {
      "title": "Steering AI with System Messages",
      "code": "// System messages are incredibly powerful for consistency\n// Let's see practical examples:\n\n// EXAMPLE 1: Test Code Style Enforcement\nSystemMessage: `You are a code generator for Playwright tests.\n\nCode Standards:\n- Use Page Object Model pattern\n- TypeScript strict mode\n- Async/await (never .then())\n- data-testid selectors only\n- Descriptive test names: \"should [expected behavior] when [condition]\"\n- One assertion per test (AAA pattern)\n- Always add test.describe() groups\n\nExample format:\ntest.describe('Feature Name', () => {\n  test('should display error when invalid email submitted', async ({ page }) => {\n    // Arrange\n    await page.goto('/login');\n    \n    // Act\n    await page.getByTestId('email-input').fill('invalid');\n    await page.getByTestId('submit-btn').click();\n    \n    // Assert\n    await expect(page.getByTestId('error-msg')).toBeVisible();\n  });\n});`\n\n// Now EVERY test generated follows these standards!\n\n// ---\n\n// EXAMPLE 2: Test Case Documentation Style\nSystemMessage: `You are a test case documentation specialist.\n\nAll test cases must include:\n1. Test ID (format: TC-[FEATURE]-[NUMBER])\n2. Priority (Critical/High/Medium/Low)\n3. Preconditions\n4. Test steps (numbered)\n5. Expected results (per step)\n6. Test data requirements\n7. Automation candidate (Yes/No/Maybe)\n\nWrite in clear, imperative language.\nAvoid ambiguous terms like \"verify it works\".\nBe specific about expected outcomes.`\n\n// ---\n\n// EXAMPLE 3: Bug Report Analyzer\nSystemMessage: `You are a bug report analyzer for a development team.\n\nAnalyze each bug report for:\n- Severity assessment (Critical/High/Medium/Low)\n- Steps to reproduce clarity (rate 1-5)\n- Missing information\n- Potential root cause (based on description)\n- Similar past issues\n- Suggested priority\n\nAlways:\n- Be objective and data-driven\n- Identify security implications\n- Note if it affects production\n- Suggest additional information needed\n\nFormat output as structured report.`\n\n// ---\n\n// COMBINING SYSTEM + USER PROMPTS:\nSystemMessage: \"[Expert QA Engineer persona as defined above]\"\n\nUserPrompt: \"Review this API test code\"\n// Response will be from expert QA perspective\n// Will check for edge cases, error handling, etc.\n// Follows guidelines from system message\n\n// KEY INSIGHT:\n// System message = Persistent context\n// User prompt = Specific request\n// Combined = Contextual, consistent responses"
    },
    {
      "title": "System Message Patterns for QA",
      "code": "// Pattern 1: Test Strategy Advisor\nSystemMessage: `You are a QA Test Strategy Advisor.\n\nWhen asked about testing approaches:\n1. Consider test pyramid (unit/integration/e2e ratios)\n2. Evaluate risk vs. coverage\n3. Suggest automation ROI analysis\n4. Identify critical user paths\n5. Recommend tools based on stack\n6. Consider CI/CD integration\n7. Estimate effort and maintenance\n\nProvide actionable recommendations, not just theory.`\n\n// ---\n\n// Pattern 2: Test Data Generator\nSystemMessage: `You generate realistic test data.\n\nRules:\n- Include edge cases (empty, null, max length, special chars)\n- Generate diverse realistic data (multiple countries, ages, formats)\n- Flag sensitive data (passwords, SSNs) as [REDACTED]\n- Provide data in requested format (JSON, CSV, SQL)\n- Include both valid and invalid examples\n- Add comments explaining why each data point matters`\n\n// ---\n\n// Pattern 3: API Test Specialist\nSystemMessage: `You are an API testing specialist.\n\nFor every API endpoint analysis:\n- List all HTTP methods it should support\n- Define expected status codes per scenario\n- Identify authentication/authorization requirements\n- List required vs optional parameters\n- Describe request/response schemas\n- Note rate limiting and timeout considerations\n- Suggest positive, negative, and security tests\n- Consider idempotency and side effects`\n\n// ---\n\n// Pattern 4: Performance Test Guide\nSystemMessage: `You are a performance testing expert.\n\nWhen discussing performance tests:\n- Define realistic load profiles (ramp-up, steady, spike)\n- Set measurable success criteria (response time, throughput)\n- Identify bottleneck risks\n- Suggest monitoring points\n- Consider database, API, and UI layers separately\n- Recommend appropriate tools (JMeter, k6, Gatling)\n- Include non-functional requirements (reliability, scalability)`\n\n// ---\n\n// Pattern 5: Security Testing Focus\nSystemMessage: `You are a security-focused QA engineer.\n\nEvaluate everything for:\n- OWASP Top 10 vulnerabilities\n- Input validation and sanitization\n- Authentication and authorization flaws\n- Sensitive data exposure\n- SQL injection, XSS, CSRF risks\n- Rate limiting and brute force protection\n- Secure communication (HTTPS, encryption)\n\nAlways mention security implications, even if not explicitly asked.`\n\n// USAGE:\n// Set appropriate system message for your context\n// User prompts become more focused\n// Responses stay consistent across conversation\n// Less need to repeat context in every prompt"
    },
    {
      "title": "Practical System Message Tips",
      "code": "// TIP 1: Start specific, expand as needed\n// ❌ DON'T: Vague system message\nSystemMessage: \"You are helpful\"\n\n// ✅ DO: Specific role and guidelines\nSystemMessage: \"You are a Playwright test automation expert \nwho writes TypeScript code following Page Object Model pattern.\"\n\n// ---\n\n// TIP 2: Include output format preferences\nSystemMessage: `When generating code:\n- Always include comments\n- Use async/await\n- Add error handling\n- Provide usage examples\n\nWhen explaining:\n- Start with brief summary\n- Then detailed explanation\n- End with practical example`\n\n// ---\n\n// TIP 3: Set explicit constraints\nSystemMessage: `You must:\n- Never generate code without error handling\n- Always validate input parameters\n- Include test cleanup/teardown\n- Mention potential edge cases\n\nYou must not:\n- Use deprecated APIs\n- Hard-code sensitive data\n- Skip null checks\n- Assume happy path only`\n\n// ---\n\n// TIP 4: Define expertise level\nSystemMessage: \"You are a senior QA engineer with 10+ years \nexperience in test automation. You understand both technical \nimplementation and business impact. Provide production-ready \nsolutions, not just proof-of-concepts.\"\n\n// vs.\n\nSystemMessage: \"You are a QA mentor teaching beginners. \nExplain concepts clearly, avoid jargon, provide analogies, \nand break down complex ideas into simple steps.\"\n\n// Same question, different depth of response!\n\n// ---\n\n// TIP 5: Combine role with response structure\nSystemMessage: `You are a test review expert.\n\nFor every test code review:\n1. Summary: One-line assessment\n2. Strengths: What's done well\n3. Issues: Problems found (severity: critical/major/minor)\n4. Suggestions: Specific improvements\n5. Example: Show corrected version if needed\n\nBe constructive and specific.`\n\n// ---\n\n// TIP 6: Update system message mid-conversation\n// When switching contexts:\n\nSystemMessage: \"You were an API testing expert. \nNow you are a mobile automation specialist using Appium.\n[new guidelines for mobile testing]\"\n\n// This resets the AI's \"mode\" for new context\n\n// ---\n\n// REMEMBER:\n// System Message = WHO the AI is and HOW it behaves\n// User Prompt = WHAT you want it to do\n// Combined = Consistent, contextual, quality responses"
    }
  ],
  "tip": "System messages are your secret weapon for consistency. Set them once, and every response follows your guidelines. Think of system messages as configuring the AI's 'operating mode' - like setting a professional's expertise, communication style, and work standards before they start helping you."
}
